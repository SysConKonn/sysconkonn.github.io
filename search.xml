<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「Manacher求最长回文子串」]]></title>
    <url>%2F2018%2F01%2F22%2F%E3%80%8CManacher%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E3%80%8D%2F</url>
    <content type="text"><![CDATA[原题戳我Manacher(马拉车)算法是用来求最长回文子串的。其实原理并不是很难，就是对暴力(Brute_Force)的优化。 问题描述最长回文子串问题，顾名思义是要求给定字符串的最长回文子串。回文串的定义就是以中心点为轴，两边的字符对称分布。 首先，讨论一下暴力算法。 Brute_Force算法对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有n^2个子串。这些子串的平均长度大约是n / 2，因此这个解法的时间复杂度是O(n^3)。 来想一下简单优化方法显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个，在每个位置上平均大约要进行\frac{n}{4}次字符比较，于是此算法的时间复杂度是O(n^2)。 最后就是看起来很厉害的Manacher算法对于一个比较长的字符串，O(n^2)的时间复杂度是难以接受的。还能再优化吗？ 先来看看解法2存在的缺陷。 由于回文串长度的奇偶性造成了不同性质的对称轴位置，解法2要对两种情况分别处理； 很多子串被重复多次访问，造成较差的时间效率。 首先我们应该解决长度奇偶性的问题，用Brute-Force方法的话，长度对称轴位置并不是一个很好确定的东西，是吧。 但是，通过小学数学可以知道，奇数加一为偶数，偶数加一为奇数，如果串长为奇数，就好处理得多了。所以就在串的间隙中插入一个不可能在题目中出现的字符(比如说#)，注意收首尾也要加上，此时加上的#个数为原串长加一，然后再加上原串长，一定为一个奇数加偶数的结果，就是一个奇数了，此时串长为奇数，对称轴好处理多了。举个例子:aba加上之后变成了:#a#b#a# 然后我们应该解决重复访问拉高复杂度的问题。我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组RL，用RL[i]表示以第i个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义RL[i]为第$i$个字符为对称轴的回文串的最右一个字符与字符i的距离。对于上面插入分隔符之后的两个串，可以得到RL数组：123456789char: # a # b # a # RL : 1 2 1 4 1 2 1RL-1: 0 1 0 3 0 1 0 i : 0 1 2 3 4 5 6char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 i : 0 1 2 3 4 5 6 7 8 通过观察可以发现，其实RL[i] - 1才是真正的回文串长 于是问题变成了，怎样高效地求的RL数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量MaxRight，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下MaxRight对应的回文串的对称轴所在的位置，记为pos，它们的位置关系如下。 当i在MaxRight左边可以用下图描述:我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以i为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到i关于pos的对称位置j，这个j对应的RL[j]我们是已经算过的。根据回文串的对称性，以i为对称轴的回文串和以j为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。(1)以j为对称轴的回文串比较短，短到像下图这样。这时我们知道RL[i]至少不会小于RL[j]，并且已经知道了部分的以i为中心的回文串，于是可以令RL[i]=RL[j]。但是以i为对称轴的回文串可能实际上更长，因此我们试着以i为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。(2)以j为对称轴的回文串很长，这么长：这时，我们只能确定，两条蓝线之间的部分（即不超过MaxRight的部分）是回文的，于是从这个长度开始，尝试以i为中心向左右两边扩展，直到左右两边字符不同，或者到达边界。 不论以上哪种情况，之后都要尝试更新MaxRight和pos，因为有可能得到更大的MaxRight。 具体操作如下:123令RL[i]=min(RL[2*pos-i], MaxRight-i)以i为中心扩展回文串，直到左右两边字符不同，或者到达边界。更新MaxRight和pos 2.当i在MaxRight的右边遇到这种情况，说明以i为对称轴的回文串还没有任何一个部分被访问过，于是只能从i的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新MaxRight和pos。 最后的最后的最后感谢 : 很有用的网站看完后不要吐槽我 最后的最后 程序 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_L 50000010#define INF 1 &lt;&lt; 31 - 1using namespace std;char s[MAX_L], s2[MAX_L];int rl[MAX_L], maxright, pos;int N, tot = 1;int res;int main () &#123; scanf("%s", s2 + 1); N = strlen(s2 + 1); for (int i = 1;i &lt;= N;i++, tot += 2) s[tot - 1] = '#', s[tot] = s2[i]; s[--tot] = '#'; maxright = pos = 0; fill(rl, rl + tot + 1, 0); for (int i = 0;i &lt;= tot; ++i) &#123; if (i &lt; maxright) rl[i] = min(maxright - i, rl[pos * 2 - i]); else rl[i] = 1; while (i - rl[i] &gt;= 0 &amp;&amp; i + rl[i] &lt;= tot &amp;&amp; (s[i + rl[i]] == s[i - rl[i]])) rl[i]++; if (rl[i] + i - 1&gt; maxright) &#123; maxright = rl[i] + i - 1; pos = i; &#125; res = max(res, rl[i]); &#125; printf("%d\n", res - 1); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2002」营业额统计 Treap模板题]]></title>
    <url>%2F2018%2F01%2F11%2F%E3%80%8CHNOI2002%E3%80%8D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1-Treap%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原题戳我题目描述Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。 该天的最小波动值=min{|该天以前某一天的营业额-该天营业额|}。 输入输出格式输入格式：第一行为正整数n（n&lt;=32767） ，表示该公司从成立一直到现在的天数，接下来的n行每行有一个整数ai(|ai|&lt;=1000000) ，表示第i天公司的营业额，可能存在负数。 输出格式：输入输出样例输入样例#1：6512546 输出样例#1： 复制12 说明结果说明：5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12 题解一道十分裸的Treap，每次插入一个点之前求出它的前驱和后继，取和它距离较近的算出最小波动值即可。前驱 : 当前序列中小于该数的最大数后继 : 当前序列中大于该数的最小树 虽说时Treap模板，但还是要知道Treap怎么打才行吧。所以就简单的介绍一下:Treap其实是BST(二叉搜索树)的平衡版本。BST:保证每个结点的左子树所有结点都比它小，右子树上所有结点都比它大的树。或者可以看wikipedia的解释。但是仔细一想，是不是很多时候，都会出现，左子树一大串，几乎已经接近一条长链，但是右子树还只有一个点的情况呢？此时就应该将它平衡，如何平衡。可以给每一个点设置一个优先级(类似于代码中的变量rd)，接下来要做的就是保证建成的树既保证BST的性质，又保证堆的性质。当插入时，如果当前结点是之前没有创建过的，就新建一个节点。若没有，该要创建的点肯定在当前访问的点的子树上，那就在它的子树中建点。注意更新它的size(变量s)。当递归建子树完成后，判断子树和它的优先度，如果子树优先度比它小，就反转它和它的子树，这是为了维持堆的性质。下面的程序中维持的是小根堆(根结点比任何一棵子树都要小)，当然实际上随便大根堆还是小根堆都可以。好了就是这么简单。 为数不多的没用指针写的Treap对了，如果想看完整版Treap(带插入，删除，查找K-th的数，查找数的排名，查找前驱、后继)-&gt; 「代码仓库:Treap」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 缩进异常难看，请适应emacs#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#define MAX_N 50010#define INF 214748647#define MOD 999999using namespace std;struct point &#123; int w, rd, sz, re, l, r;&#125;p[MAX_N];int root, ans, tot;long long N, num[MAX_N], sum, pre_, nxt_;int rand_ () &#123; int a, b; //return a * b * (a - b) * (a + b) % MOD; return 1;&#125;void up (int x) &#123;p[x].sz = p[p[x].l].sz + p[p[x].r].sz + p[x].re;&#125;void r_rot (int &amp;x) &#123; int y = p[x].r; p[x].r = p[y].l; p[y].l = x; p[y].sz = p[x].sz; up(x); x = y;&#125;void l_rot (int &amp;x) &#123; int y = p[x].l; p[x].l = p[y].r; p[y].r = x; p[y].sz = p[x].sz; up(x); x = y;&#125;void ins (long long x, int&amp; k) &#123; if (k == 0) &#123; tot++; k = tot; p[k].w = x; p[k].sz = p[k].re = 1; p[k].rd = rand(); return; &#125; p[k].sz++; if (p[k].w == x) p[k].re++; else &#123; if (x &gt; p[k].w) &#123; ins(x, p[k].r); if (p[k].rd &gt; p[p[k].r].rd) r_rot(k); &#125; else &#123; ins(x, p[k].l); if (p[k].rd &gt; p[p[k].l].rd) l_rot(k); &#125; &#125;&#125;void pre (long long x, int k) &#123; if (k == 0) return; if (p[k].w &lt;= x) &#123; ans = k; pre(x, p[k].r); &#125; else pre(x, p[k].l);&#125;void nxt (long long x, int k) &#123; if (k == 0) return; if (p[k].w &gt;= x) &#123; ans = k; nxt(x, p[k].l); &#125; else nxt(x, p[k].r);&#125;int main () &#123; srand(0); scanf("%lld", &amp;N); p[0].w = INF; for (int i = 1;i &lt;= N; ++i) &#123; scanf("%lld", &amp;num[i]); &#125; sum = num[1]; ins(num[1], root); for (int i = 2;i &lt;= N; ++i) &#123; pre(num[i], root); int x = ans; nxt(num[i], root); sum += (long long)min(abs(num[i] - p[x].w), abs(p[ans].w - num[i])); ins(num[i], root); &#125; printf("%lld\n", sum); return 0;&#125;cpp]]></content>
      <tags>
        <tag>Treap</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2011」阿狸的打字机]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%8CNOI2011%E3%80%8D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[原题戳我题目背景阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。 题目描述打字机上只有28个按键，分别印有26个小写英文字母和’B’、’P’两个字母。经阿狸研究发现，这个打字机是这样工作的： ·输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。 ·按一下印有’B’的按键，打字机凹槽中最后一个字母会消失。 ·按一下印有’P’的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入aPaPBbP，纸上被打印的字符如下： a aa ab 我们把纸上打印出来的字符串从1开始顺序编号，一直到n。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数(x,y)（其中1≤x,y≤n），打字机会显示第x个打印的字符串在第y个打印的字符串中出现了多少次。 阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？ ### 输入输出格式 输入格式：输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。 第二行包含一个整数m，表示询问个数。 接下来m行描述所有由小键盘输入的询问。其中第i行包含两个整数x, y，表示第i个询问为(x, y)。 输出格式：输出m行，其中第i行包含一个整数，表示第i个询问的答案。 输入输出样例输入样例#1：aPaPBbP31 21 32 3 输出样例#1：210 说明数据范围:对于100%的数据，n&lt;=100000,m&lt;=100000,第一行总长度&lt;=100000。 题解这题当时拿到也没什么想法，跪了两天加上Dra大神的提示(大法师(DFS)序+AC自动机+线段树)还是站起来了。其实就是根据题目输入的特性来对AC自动机做一点优化首先，想到的可能就是这是一道很明显的多个模式串匹配多个文本串的题目，而且模式串和文本串集合是一样的。但是，如果暴力的一个个匹配每一个输入的串，复杂度可能要达到整个打印出的字符串总长度看上取似乎是10^5，但是如果一直输入一个串然后不停的PBPBPBPBP可能会达到10^9级别。(也可能没算对)所以我们需要进行一些改进。 从题目可知，只需按照输入数据模拟就可以成功的建出一棵(颗)Trie(da)树(baicai)这是简单的输入，接着我们造出fail数组顺便建一颗fail树。此时到了我们需要进行进一步处理的地方。由于题目输入的特性，Trie树是根据一步步的模拟进行的。所以如果一个字符串在另一个字符串中出现，那在模拟中也会走到这个字符串的结点。所以只需模拟栈，输入该字符进栈(即输入到Trie树中加入节点)就将贡献+1若出栈(即将这个字符串进行’B’操作)就将贡献-1(因为此时它已经不在了)等到需要结算时(正在进行’P’操作)，就将关于它的询问都进行一次查找。从AC自动机简单版求出现次数博客中可以知道将待求出现次数的结点所在fail树的子树(包括自己)贡献总和就可以求出出现次数了。看完上面的文字，肯定已经都想出来了–还有地方可以优化!正确对每个结点的贡献+1, -1(注意是在fail树中进行的操作)以及对fail树进行子树遍历结算时，不都是像极了单点修改区间查询吗？只不过时fail树看起来不满足区间修改而已。但是可以注意到，再一棵树的DFS序中，一个结点和它的子树肯定是在一段连续区间上的，所以我们可以将fail树转化成DFS序进行修改和查询。然后再思考一遍，理清头绪，就可以开始打了。 吐槽蒟蒻不禁吐槽程序真难打。我一开始还以为进行’B’操作时需要删掉在Trie树上的点，结果还用个stack装结构体来读入。结果Dra后来说不用删点。但我还是不太知道为什么不用(蒟蒻太水还没想出来) 程序 (可能还比较清晰吧)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 100100using namespace std;struct str &#123; char s; bool book;&#125;;stack&lt;str&gt; stk;char t[MAX_N];int ch[MAX_N][30], sz = 1, fa[MAX_N];int strin[MAX_N], strsum;int M;int head[MAX_N], to[MAX_N], nxt[MAX_N], ttop;int fail[MAX_N];int fail_head[MAX_N], fail_to[MAX_N], fail_nxt[MAX_N], x[MAX_N], failtop;int totans[MAX_N];int bit[MAX_N * 2];int idx (char c) &#123;return c - 'a';&#125;void Read () &#123; int len_ = strlen(t); int u = 0; for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(t[i]); if (t[i] == 'P') &#123; stk.top().book = true; strin[++strsum] = u; &#125; else if (t[i] == 'B') &#123; if (stk.top().book == true) &#123; //当前删除的是合法的点，不用烧边，把正确标记移至下一个字符 stk.pop(); if (!stk.empty()) stk.top().book = true; u = fa[u]; //向上到上一层点 &#125; else &#123; ch[fa[u]][stk.top().s - 'a'] = 0; //它的上一层向它无边(烧边) stk.pop(); u = fa[u]; sz--; //这条边不算数 &#125; &#125; else &#123; if (ch[u][c]) &#123;u = ch[u][c];continue;&#125; ch[u][c] = sz++; //加一条边 fa[sz - 1] = u; //记录它的上层节点编号，以便于删除时向上 stk.push((str)&#123;t[i], false&#125;); //将当前字符串压入栈中，初始值为false因为当时还没有P是一个不合法的值 u = ch[u][c]; //跳到下一个点 &#125; &#125;&#125;void fail_AddEdge (int _from_, int _to_) &#123; fail_nxt[++failtop] = fail_head[_from_]; fail_head[_from_] = failtop; fail_to[failtop] = _to_; &#125;void getfail () &#123; queue&lt;int&gt; q; fail[0] = 0; for (int i = 0;i &lt; 26; ++i) if (ch[0][i]) &#123; //AddEdge fail_AddEdge(0, ch[0][i]); q.push(ch[0][i]); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int c = 0;c &lt; 26; ++c) &#123; if (!ch[u][c]) continue; q.push(ch[u][c]); int v = fail[u]; while (v &amp;&amp; !ch[v][c]) v = fail[v]; fail[ch[u][c]] = ch[v][c]; //AddEdge int _from_ = ch[v][c], _to_ = ch[u][c]; fail_AddEdge(_from_, _to_); &#125; &#125;&#125;int tot;int l[MAX_N], r[MAX_N], order_[MAX_N], iorder_[MAX_N];void get_dfs_order (int x, int fa) &#123; l[x] = ++tot; order_[tot] = x; iorder_[x] = tot; for (int now = fail_head[x]; now; now = fail_nxt[now]) &#123; int _to = fail_to[now]; if (_to == fa) continue; get_dfs_order(_to, x); &#125; r[x] = tot;&#125;int bit_find (int i) &#123; int s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void bit_add (int i, int x) &#123; while (i &lt;= tot) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;void rebuild () &#123; int pt = 0, u = 0; int len_ = strlen(t); for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(t[i]); if (t[i] == 'P') &#123; ++pt; for (int i = head[pt]; i; i = nxt[i]) &#123; int now = strin[to[i]]; totans[x[i]] = bit_find (r[now]) - bit_find(l[now] - 1); &#125; &#125; else if (t[i] == 'B') &#123; bit_add(l[u], -1); u = fa[u]; &#125; else &#123; bit_add(l[ch[u][c]], 1); u = ch[u][c]; &#125; &#125;&#125;int main () &#123; scanf("%s", t); Read(); getfail(); scanf("%d", &amp;M); int _book_[MAX_N]; memset(_book_, 0, sizeof(_book_)); for (int i = 1;i &lt;= M; ++i) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); _book_[b] = 1; nxt[++ttop] = head[b]; head[b] = ttop; to[ttop] = a; x[ttop] = i; &#125; get_dfs_order(0, 0); rebuild(); for (int i = 1;i &lt;= M; ++i) printf("%d\n", totans[i]); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ'Hello2018'-A」奴隶主的游戏]]></title>
    <url>%2F2018%2F01%2F03%2F%E3%80%8CLOJ-Hello2018-A%E3%80%8D%E5%A5%B4%E9%9A%B6%E4%B8%BB%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目题目描述奴隶主家的公告：欢迎和我玩数独游戏，赢了你将获得万贯家财，输了 …… 而你正好看到这则公告 数独游戏的规则是这样的： 初始的时候有一个 n 阶数独（n 阶数独即边长为 n^2 的分成 n^2 个 n×n 区域的方格，下图为 4 阶数独），并且已经填了 k 个格子，现在两个人轮流在空格子中填数（当然是你先填啦），每次填完需保证局面合法（合法即要求每个人填完后同行同列同区域不能出现相同数字并且填的数字是 [1,n^2] 中的整数），能填必须填，不能填者输。 现在你要确定你（先手）是否有必胜策略，以免鲁莽输掉游戏沦为奴隶。 输入格式第一行一个整数 T 表示有 T 组数据。 对于每组数据第一行两个整数 n,k。 接下来有 kkk 行，每行三个整数 x,y,z 表示第 x 行 y 列填了数字 z。保证填的格子不重复，且已经填好的数字合法。 输出格式对于每组数据输出一个字符串：YES 表示有必胜策略，NO 表示没有必胜策略。 样例注意：样例中有 1≤n&lt;4 的情况，这只是为了便于解释样例及说明游戏规则，在实际的测试数据中保证 n≥4。 样例输入 111 0 样例输出 1YES 样例解释 1初始局面是一个 1x1的方块并且没有填，你只要填上 1 就可获胜。 样例输入 214 29 13 19 16 2 样例输出 2NO 样例解释 2输入即为上图填了 1 和 2 后的局面。 数据范围与提示对于所有数据，4​≤n≤5, 0≤k≤2, 1≤T≤20, 1≤x, y, z≤n^2。 保证填的格子不重复，且已经填好的数字合法。 题解其实题目很简单， 找规律就可以以下就找出来。你想想自己应该怎么样才能赢，也就是想想最优策略。在一个2x2 x 2x2 的小方格中和自己玩了一盘后，我大概知道怎么样才能获胜了。可以把这个数独想象成一个棋盘。我们一定可以找到棋盘的中心，对方每下一步，你就下一步相对于棋盘的中心与他所下棋对称的。这样只需考虑谁最后会下完整盘棋的最后一个子，他就赢了。然后只要考虑棋盘中可下空位的奇偶性。代码也就出来了，非常短。(十足的水题)123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int T, N, K;int main () &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;N, &amp;K); int sum = N * N * N * N; int x, y, z; for (int i = 1;i &lt;= K; ++i) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); &#125; int res = sum - K; if (res % 2 == 0) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>LOJ</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>LOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3808AC自动机简单版]]></title>
    <url>%2F2017%2F12%2F30%2Fluogu3808AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目原题戳我 题目背景这是一道简单的AC自动机模板题。 用于检测正确性以及算法常数。 为了防止卡OJ，在保证正确的基础上只有两组数据，请不要恶意提交。 管理员提示：本题数据内有重复的单词，且重复单词应该计算多次，请各位注意 题目描述给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。 输入输出格式输入格式：第一行一个n，表示模式串个数； 下面n行每行一个模式串； 下面一行一个文本串。 输出格式：一个数表示答案 先简单介绍一下AC自动机Aho-Corasick(简称AC)自动机是解决多个模板匹配一个文本串的算法.同(xiao)学(xue)们(sheng)都知道KMP算法是解决一个模式串匹配一个文本串的算法。但是如果模式串有很多个，KMP就不太合适了，因为每查找一次文本串都要匹配一次模式串，怎么样可以直接一次遍历呢？那就需要用AC自动机了 大概思路其实AC自动机和KMP算法有一定的相似度。KMP的状态转移图是线性的(一个)字符串加上失配边组成的。所以思考怎样把多个字符串整合到一起。那就用一个Trie树就可以了，Trie树可以将多个字符串整合到一个图中以便于查找。 下图1.1为{he,she,his,hers}的Trie 1.2为对应的AC自动机，虚线表示它的fail值所以构造好Trie树后，匹配算法和KMP几乎一样。 需要提及的在Trie树中把文本串走过一遍之后，怎么才能求出每个匹配串的出现次数？我们需要建一个fail树每个子节点的父节点就是父节点在Trie树中的所代表节点的fail指向的节点e.g.若按图中所示Trie树建fail树，则最右端(‘hers’中的)’s’节点和最上端(‘his’中的)’s’节点的父节点是最下端(‘she’中的)’s’节点在在Trie树中匹配文本串时，肯定会有一条路径，我们就把路径上的节点都设置一个代表值val[],每个访问到的节点都val[i]++。最后用DFS查找每个单词在Trie树中对应的(尾端)节点 在fail树中对应的子树上所有点（包括自己）的val[]总和。证明略过。 程序(查找所有模式串出现次数总和)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAX_L 1000006#define MAX_N 500#define INF 2147483647using namespace std;int N;char s[MAX_L];int s_[MAX_L];char t[MAX_L];struct ac &#123; int ch[MAX_L][30]; int val[MAX_L]; int fail[MAX_L]; int ifail[MAX_L][30]; int sz = 1; int toti = 0; int idx(char c) &#123;return c - 'a';&#125; void insert (char* s, int t) &#123; int u = 0, len_ = strlen(s); for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); ch[u][c] = sz++; &#125; fail[ch[u][c]] = u; u = ch[u][c]; &#125; s_[t] = u; &#125; void getfail() &#123; queue&lt;int&gt; Q; fail[0] = 0; for (int i = 0;i &lt; 26; ++i) &#123; if (ch[0][i]) &#123; Q.push(ch[0][i]); &#125; &#125; while (!Q.empty()) &#123; int x = Q.front();Q.pop(); for (int i = 0;i &lt; 26; ++i) &#123; int u = ch[x][i]; if (!u) continue; Q.push(u); int v = fail[x]; while (v &amp;&amp; !ch[v][i]) v = fail[v]; fail[u] = ch[v][i]; ifail[fail[u]][i] = u; &#125; &#125; &#125; void search (char* t) &#123; int len_ = strlen(t); int k = 0; for (toti = 0; toti &lt; len_; ++toti) &#123; int c = idx(t[toti]); while (k &amp;&amp; !ch[k][c]) k = fail[k]; k = ch[k][c]; val[k]++; &#125; &#125; int dfs(int x) &#123; int sum = 0; for (int i = 0;i &lt; 26; ++i) if (ifail[x][i]) sum++; if (sum == 0) return val[x]; sum = val[x]; for (int i = 0;i &lt; 26; ++i) &#123; if (!ifail[x][i]) continue; sum += dfs(ifail[x][i]); &#125; return sum; &#125; int find (int u) &#123; int res = dfs(u); return res; &#125;&#125;;ac aho;int main () &#123; scanf("%d", &amp;N); for (int i = 0;i &lt; N; ++i) &#123; scanf("%s", s); aho.insert(s, i); &#125; aho.getfail(); scanf("%s", t); aho.search(t); int res = 0; for (int i = 0;i &lt; N; ++i) &#123; res += aho.find(s_[i]) &gt; 0 ? 1 : 0; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3976AC自动机加强版]]></title>
    <url>%2F2017%2F12%2F30%2Fluogu3976AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P3796 题目描述有N个由小写字母组成的模式串以及一个文本串T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多。 输入输出格式输入格式：输入含多组数据。 每组数据的第一行为一个正整数N，表示共有N个模式串，1≤N≤150。 接下去N行，每行一个长度小于等于70的模式串。下一行是一个长度小于等于10^6的文本串T。 输入结束标志为N=0。 输出格式：对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。 简述这一个其实和简单版差不多，就是多了多组数据，然后查询的是最大值。就只是稍微做一点改动，然后记得init。这题程序其实不是特别对的，因为我是针对的某些小一点的数据初始化的。代码比简单版长一些。可以参考简单版的博客:https://sysconkonn.github.io/2017/12/30/luogu3808AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95%E7%89%88/ 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAX_L 1000006#define MAX_N 160#define INF 2147483647using namespace std;int N;char s[MAX_N][100];int s_[150];char t[MAX_L];struct ac &#123; int ch[MAX_L][30]; int val[MAX_L]; int fail[MAX_L]; int ifail[MAX_L][30]; int sz = 1; int toti = 0; int idx(char c) &#123;return c - 'a';&#125; void init() &#123; memset(ch, 0, sizeof(ch)); &#125; void insert (char* s, int t) &#123; int u = 0, len_ = strlen(s); for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); ch[u][c] = sz++; &#125; fail[ch[u][c]] = u; u = ch[u][c]; &#125; s_[t] = u; &#125; void getfail() &#123; queue&lt;int&gt; Q; fail[0] = 0; for (int i = 0;i &lt; 26; ++i) &#123; if (ch[0][i]) &#123; Q.push(ch[0][i]); &#125; &#125; while (!Q.empty()) &#123; int x = Q.front();Q.pop(); for (int i = 0;i &lt; 26; ++i) &#123; int u = ch[x][i]; if (!u) continue; Q.push(u); int v = fail[x]; while (v &amp;&amp; !ch[v][i]) v = fail[v]; fail[u] = ch[v][i]; ifail[fail[u]][i] = u; //printf("%d %c : %d\n", u, i + 'a' , fail[u]); &#125; &#125; &#125; void search (char* t) &#123; int len_ = strlen(t); int k = 0; for (toti = 0; toti &lt; len_; ++toti) &#123; int c = idx(t[toti]); while (k &amp;&amp; !ch[k][c]) k = fail[k]; k = ch[k][c]; val[k]++; &#125; &#125; int dfs(int x) &#123; int sum = 0; for (int i = 0;i &lt; 26; ++i) if (ifail[x][i]) sum++; if (sum == 0) return val[x]; sum = val[x]; for (int i = 0;i &lt; 26; ++i) &#123; if (!ifail[x][i]) continue; sum += dfs(ifail[x][i]); &#125; return sum; &#125; int find (int u) &#123; int res = dfs(u); return res; &#125;&#125;;ac aho;int ans = 0;int main () &#123; while (1) &#123; scanf("%d", &amp;N); if (N == 0) break; if (N &lt;= 20) aho.init(); for (int i = 0;i &lt; N; ++i) &#123; scanf("%s", s[i]); aho.insert(s[i], i); &#125; aho.getfail(); scanf("%s", t); aho.search(t); int res = 0; int _s[150]; for (int i = 0;i &lt; N; ++i) &#123; _s[i] = aho.find(s_[i]); res = max(_s[i], res); &#125; printf("%d\n", res); for (int i = 0;i &lt; N; ++i) &#123; if (_s[i] == res) printf("%s\n", s[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈KMP算法]]></title>
    <url>%2F2017%2F12%2F29%2F%E6%B5%85%E8%B0%88KMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单介绍明天要学Aho-Corasick(AC)自动机了,今天再复习一下KMP，可能有助于明天的听课吧。KMP算法，是在一个字符串(源串)s中匹配一个模式串t出现位置的算法。什么叫出现?就是s[j] = t[1], s[j+1] = t[2], …, s[j+n-1] = t[n]如果用朴素算法(小学生都知道)的话最坏时复杂度会达到O(m(n-1))而KMP算法只需O(m+n)在这里就不说多了，因为毕竟只是当AC自动机的铺垫下面这张图是KMP的精髓: 假定在匹配中，正在比较的文本串位置和模板串abbaaba最后一个字符不符合（失配），这是朴素算法会将模板串右移一位，继续比较，但是kmp不这样做，kmp认为既然’!!’位置已经比较过，应该可以利用模板串本身属性判断出右移一位不能匹配，同理，右移两位或者三位也不行，但是右移四位是有可能的。这个时候，需要比较 ‘*’处的字符和abbaaba的第三个字符。 上图下面那个链状图就是一个状态机，其中编号为i的节点表示已经匹配了i个字符，匹配开始是0，如果成功匹配则+1，失配时‘沿着失配边走’，如果在状态6处失配，应转到状态2.为了方便，这里使用失配函数f[i]表示状态i失配时应转移到的新状态，要特别注意的是f[0]=0。 如果没有看懂可以看看下面这篇CSDN博客，感觉挺有帮助的: http://blog.csdn.net/to_be_better/article/details/49086075程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX_N 1000001using namespace std;char s[MAX_N], t[MAX_N];void getNext (int len_, int maxl[]) &#123; for(int i = 1, k = 0;i &lt; len_; ++i) &#123; while(k &gt; 0 &amp;&amp; t[i] != t[k]) k = maxl[k - 1]; if(t[k] == t[i]) k++; maxl[i] = k; &#125;&#125;void print (int i, int j) &#123; printf("%d\n", i - j + 1);&#125;void search (int len_s, int len_t, int maxl[]) &#123; for(int i = 0, j = 0;i &lt; len_s; ++i) &#123; while(j &gt; 0 &amp;&amp; s[i] != t[j]) j = maxl[j - 1]; if(s[i] == t[j]) j++; if(j == len_t) print(i, j - 1); &#125;&#125;int main () &#123; scanf("%s", s); scanf("%s", t); int len1 = strlen(s), len2 = strlen(t); int maxl[len1]; memset(maxl, 0, sizeof(maxl)); //获得匹配字符串t的next数组 getNext(len2, maxl); search(len1, len2, maxl); for(int i = 0;i &lt; len2; ++i) printf("%d ", maxl[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468区间修改区间查询模板题]]></title>
    <url>%2F2017%2F12%2F29%2Fpoj3468%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目A Simple Problem with IntegersTime Limit: 5000MS Memory Limit: 131072K Case Time Limit: 2000MSDescriptionYou have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. “C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000. “Q a b” means querying the sum of Aa, Aa+1, … , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 Sample Output455915 HintThe sums may exceed the range of 32-bit integers. 题解就是节约一点时间，不要访问的就懒得加下去了，弄一个tag数组，如果tag[i]不为0，就说明它的子树和以下所有节点都应该加上tag[i],重要的一点是你需要保证每一个所到达的节点都是正确的，所以你在访问到某个节点(它已经是正确的了)，你需要push_down，这样才可以保证其下面的两个直接子节点都是正确的。总的来说：就是保证三点: 到达的每个节点当前的值是正确的 每个节点的tag值都是它和底下所有节点都需要加上的 每访问某个节点都要push_down(把tag[]里的值加到子节点)使得子节点的值正确. 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include #include #include #include #include #define MAX_N 1000010typedef long long ll;using namespace std;int N, Q;ll dat[MAX_N * 4], tag[MAX_N * 4], p[MAX_N];long long mk_tree(int l, int r, int now) &#123; if (l == r) return dat[now] = p[l]; return dat[now] = mk_tree(l, (l + r) / 2, now * 2) + mk_tree((l + r) / 2 + 1, r, now * 2 + 1);&#125;void push_down (int k, int l, int r, int val) &#123; int l1 = l, l2 = (l + r) / 2 + 1, r1 = (l + r) / 2, r2 = r; tag[k * 2] += val; tag[k * 2 + 1] += val; dat[k * 2] += 1LL * val * (r1 - l1 + 1); dat[k * 2 + 1] += 1LL * val * (r2 - l2 + 1); tag[k] = 0;&#125;void add(int a, int b, int x, int k, int l, int r) &#123; if (r &lt; a || b &lt; l) return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; tag[k] += x; dat[k] += 1LL * x * (r - l + 1); push_down(k, l, r, tag[k]); return; &#125; else if (a &lt;= r &amp;&amp; l &lt;= b) &#123; //tag[k] += x; dat[k] += 1LL * (min(b, r) - max(a, l) + 1) * x; push_down(k, l, r, tag[k]); add(a, b, x, k * 2, l, (l + r) / 2); add(a, b, x, k * 2 + 1, (l + r) / 2 + 1, r); &#125;&#125;long long sum(int a, int b, int k, int l, int r) &#123; if (r &lt; a || b &lt; l) return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; return dat[k]; &#125; else if (a &lt;= r &amp;&amp; l &lt;= b) &#123; push_down(k, l, r, tag[k]); return sum(a, b, k * 2, l, (l + r) / 2) + sum(a, b, k * 2 + 1, (l + r) / 2 + 1, r); &#125;&#125;int main () &#123; while (~scanf("%d%d", &amp;N, &amp;Q)) &#123; memset(dat, 0, sizeof(dat)); memset(tag, 0, sizeof(tag)); memset(p, 0, sizeof(p)); for (int i = 1;i &lt;= N; ++i) scanf("%lld", &amp;p[i]); dat[1] = mk_tree(1, N, 1); char s[6]; for (int i = 1;i &lt;= Q; ++i) &#123; getchar(); scanf("%s", s); if (s[0] == 'C') &#123; int l, r, d; scanf("%d%d%d", &amp;l, &amp;r, &amp;d); add(l, r, d, 1, 1, N); &#125; else if (s[0] == 'Q') &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%lld\n", sum(l, r, 1, 1, N)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1754I Hate It题解-线段树模板题]]></title>
    <url>%2F2017%2F12%2F29%2FHDU1754I-Hate-It%E9%A2%98%E8%A7%A3-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[十分简单的单点修改区间+查询最大值。 线段树原理就不解释了，反正都知道。贴一个图助于理解好了。 因为太简单所以直接上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include #include #include #include #define MAX_N 300010#define MAX_Q 1000040#define INF 2147483647using namespace std;int N, Q;long long ST_Max[MAX_N * 4 + 1];long long H[MAX_N];int top = 0;int pos[MAX_N], max_;long long _max(long long a, long long b) &#123; return a &lt; b ? b : a;&#125;int AT_Max(int l, int r, int now) &#123; max_ = _max(max_, now); if(l == r) &#123;pos[l] = now;return ST_Max[now] = H[l];&#125; return ST_Max[now] = _max(AT_Max(l, (l + r) / 2, now * 2), AT_Max((l + r) / 2 + 1, r, now * 2 + 1));&#125;long long find_Max(int l, int r, int lsum, int rsum, int now) &#123; if(l &gt; rsum || r &lt; lsum) return -INF; if(l &gt;= lsum &amp;&amp; r &lt;= rsum) return ST_Max[now]; return _max(find_Max(l, (l + r) / 2, lsum, rsum, now * 2), find_Max((l + r) / 2 + 1, r, lsum, rsum, now * 2 + 1));&#125;void cag (int x, int a) &#123; x = pos[x]; ST_Max[x] = a; while (x &gt; 0) &#123; //printf("%d\n", x); x = (x ^ 1) / 2; ST_Max[x] = _max(ST_Max[x * 2], ST_Max[x * 2 + 1]); &#125;&#125;void find_() &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); long long res = find_Max(1, N, l, r, 1); printf("%lld\n", res);&#125;void change() &#123; int x, a; scanf("%d%d", &amp;x, &amp;a); cag(x, a);&#125;void print() &#123; int sum = 1; for (int i = 1;sum &lt;= max_; ++i) &#123; for (int j = 1;j &lt;= pow(2, i - 1); ++j) printf("%lld ", ST_Max[sum++]); printf("\n"); &#125;&#125;int main() &#123; while(scanf("%d%d", &amp;N, &amp;Q) == 2) &#123; memset(H, 0, sizeof(H)); memset(ST_Max, 0, sizeof(ST_Max)); memset(pos, 0, sizeof(pos)); for(int i = 1;i &lt;= N; i++) scanf("%lld", &amp;H[i]); ST_Max[1] = AT_Max(1, N, 1); for (int i = 1;i &lt;= Q; ++i) &#123; char c[20]; scanf("%s", c); //print(); if (c[0] == 'Q') find_(); else change(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>HDU</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3376最大流模板题]]></title>
    <url>%2F2017%2F12%2F29%2Fluogu3376%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不解释，直接上代码(这一份写的不好，不正规，并不想多加解释了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 10001#define INF 2147483647using namespace std;struct Edge &#123; int to, cap; Edge(int v, int d):to(v), cap(d) &#123;&#125;&#125;;vector &lt;Edge&gt; edges[MAX_N];int N, M;int s, t;int dep[MAX_N], idep[MAX_N];void bfs (int s) &#123; memset(dep, -1, sizeof(dep)); memset(idep, 0, sizeof(idep)); queue&lt;int&gt; Q; while (!Q.empty()) Q.pop(); dep[s] = 0; idep[0]++; Q.push(s); while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (int i = 0;i &lt; edges[now].size(); ++i) &#123; Edge&amp; e = edges[now][i]; if(e.cap &gt; 0 &amp;&amp; dep[e.to] &lt; 0) &#123; dep[e.to] = dep[now] + 1; idep[dep[e.to]]++; Q.push(e.to); &#125; &#125; &#125;&#125;int find_ (int x, int u) &#123; for (int i = 0;i &lt; edges[u].size(); ++i) if(edges[u][i].to == x) return i;&#125;int dfs (int now, int flow) &#123; //printf("OK"); if(now == t) return flow; for(int i = 0;i &lt; edges[now].size(); ++i) &#123; Edge&amp; e = edges[now][i]; if((dep[e.to] == dep[now] + 1) &amp;&amp; (e.cap &gt; 0)) &#123; int f = dfs(e.to, min(flow, e.cap)); if(f &gt; 0) &#123; e.cap -= f; edges[e.to][find_(now, e.to)].cap += f; return f; &#125; &#125; &#125; return 0;&#125;void print (int out) &#123; printf("%d\n", out); exit(0);&#125;void add_ (int u, int v, int cap) &#123; edges[u].push_back(Edge(v, cap)); edges[v].push_back(Edge(u, 0));&#125;void db (int);int check () &#123; bool book = false; int sum = 0; for (int i = 0;sum &lt; N &amp;&amp; i &lt; N; ++i) &#123; if(idep[i] == 0) book = true; sum += idep[i]; &#125; if (book == true) return 1; return 0;&#125;int main () &#123; scanf("%d%d", &amp;N, &amp;M); scanf("%d%d", &amp;s, &amp;t); for(int i = 1;i &lt;= M; ++i) &#123; int u, v, cap; scanf("%d%d%d", &amp;u, &amp;v, &amp;cap); add_(u, v, cap); &#125; int res = 0; int d = 0; for (;;) &#123; bfs(s); if(dep[t] &lt; 0) print(res); while(d = dfs(s, INF)) res += d; &#125; print(res); return 0;&#125;void db (int res) &#123; printf("%d\n", res); for(int i = 1;i &lt;= N; ++i) printf("%d ", dep[i]); printf("\n"); for(int i = 0;i &lt; N; ++i) printf("%d ", idep[i]); printf("\n"); int sum = 0; for(int i = 0;sum &lt; N &amp;&amp; i &lt; N; ++i) &#123; sum += idep[i]; printf("%d %d\n", i, sum); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1830题解-开关问题]]></title>
    <url>%2F2017%2F12%2F29%2Fpoj1830%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开关问题Time Limit: 1000MS Memory Limit: 30000K Description有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序） Input输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &lt; N &lt; 29） 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。 Output如果有可行方法，输出总数，否则输出“Oh,it’s impossible~!!” 不包括引号 Sample Input230 0 01 1 11 21 32 12 33 13 20 030 0 01 0 11 22 10 0 Sample Output4Oh,it’s impossible~!!Hint 第一组数据的说明：一共以下四种方法： 操作开关1 操作开关2 操作开关3 操作开关1、2、3 （不记顺序） 题解这题其实挺水的，但是可能由于是晚上想的而且没有特别开动脑筋吧，结果做完之后WA了7还是8次， 当时每次提交我的心都在滴血，最后调试了1个多小时后，终于发现是求开头要替换的那个求错了， (说不清楚，反正也不重要了)，果然要打代码打标准啊。 怎么做呢? 就是一个简单的高斯消元，首先对于每个灯肯定只有开着或关着，按了或者没按，并且结果(也就是最后灯是开着还是关着)是每次可影响它的灯按了之后加上自己的影响的结果， 观察一下可以发现，如果每个灯按了记作1，不然记作0，每个灯受的影响异或起来就是结果。 举个例子: 设一个灯受了3个灯的影响 ，则因为1^1^1=1，它的结果是1，也就是亮着. 因为有N个灯，就造一个N*N的方阵A，第i行第j个位置表示灯j对灯i有没有影响(有就是1，否则0) 再造一个N的数组存结果，开了就是1，否则0. 最后高斯消元，就是把消系数改成若两个系数不同就把第二排和第一排异或一下。 最后记录自由元的个数(设为x)方案数就是2^x. 若某一行系数全是0结果却是1，那这是不可能的。 怎么求自由元？若A[i][i] = 0则第i个灯是自由元。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define MAX_N 30using namespace std;int fr[MAX_N], be[MAX_N];int A[MAX_N][MAX_N], B[MAX_N];int free_x[MAX_N];int N;int check_ () &#123; for(int i = 1;i &lt;= N; ++i) &#123; int sum = 0; for(int j = 1;j &lt;= N; ++j) if(A[i][j] == 0) sum++; if(sum == N &amp;&amp; B[i] == 1) return 1; &#125; return 0;&#125;void print_false () &#123; printf("Oh,it's impossible~!!\n");&#125;void cal () &#123; int res = 1; for(int i = 1;i &lt;= N; ++i) if(free_x[i]) res *= 2; printf("%d\n", res);&#125;void gauss () &#123; memset(free_x, 0, sizeof(free_x)); for(int i = 1;i &lt;= N; ++i) &#123; int k = i; for (int j = i+1; j &lt;= N; ++j) if (A[j][i] &gt; A[k][i]) k = j; if(A[k][i] == 0) free_x[i] = 1; if (k != i)&#123; for (int j = 1; j &lt;= N; ++j) std::swap(A[i][j], A[k][j]); std::swap(B[i], B[k]); &#125; for(int j = i + 1;j &lt;= N; ++j) &#123; if(A[j][i] == 0) continue; for(int k = 1;k &lt;= N; ++k) A[j][k] ^= A[i][k]; B[j] ^= B[i]; &#125; &#125; if(check_() == 1) print_false(); else cal();&#125;void solve () &#123; //Read() scanf("%d", &amp;N); for(int i = 1;i &lt;= N; ++i) scanf("%d", &amp;fr[i]); for(int i = 1;i &lt;= N; ++i) &#123; scanf("%d", &amp;be[i]); B[i] = fr[i] ^ be[i]; &#125; int a, b; for(int i = 1;i &lt;= N; ++i) A[i][i] = 1; while(scanf("%d%d", &amp;a, &amp;b) == 2 &amp;&amp; a != 0 &amp;&amp; b != 0) A[b][a] = 1; gauss();&#125;void init () &#123; memset(fr, 0, sizeof(fr)); memset(be, 0, sizeof(be)); memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B));&#125;int main () &#123; int ntot; scanf("%d", &amp;ntot); while(ntot--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元模板题luogu3389题解]]></title>
    <url>%2F2017%2F12%2F29%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF%E9%A2%98luogu3389%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目背景Gauss消元 题目描述给定一个线性方程组，对其求解 输入输出格式输入格式：第一行，一个正整数 nnn 第二至 n+1行，每行 n+1 个整数，为a1, a2 … an和 b，代表一组方程。 输出格式：共n行，每行一个数，第 i行为x_i （保留2位小数） 如果不存在唯一解，在第一行输出”No Solution”. 输入输出样例输入样例#1： 31 3 4 51 4 7 39 3 2 2输出样例#1： -0.975.18-2.39 说明 1≤n≤100,∣ai∣≤104,∣b∣≤104 解题报告 这就是个高斯消元的模板题，一开始还认为很难，又找wikipedia,又找百度百科. 虽然最后没有什么用，但是还是把链接贴上: wiki : https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95 baidu : https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/619561?fr=aladdin 一开始看完wiki上面的高斯消元大概知道只有唯一解的方法怎么写了，但是唯一一个问题就是 怎么判断无解或者有多个解。 所以就因为这个问题看wiki和百科看了一个多小时，最后还是不懂(不禁吐槽wiki后面写的晦涩难懂) 后来问了dra, 他就说这题很简单，你直接用平常你解方程的方法去判断 我一想，好像就是这样就可以了。 然后怎么会无解呢:已知最后会化简成a * x = b的形式，如果此时系数a为0就不行。 怎么会又无穷多个解呢: 就是存在自由元啊，如果matr[i][i]==0说明x[i]是个自由元. 所以这题就做出来了. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define MAX_N 1005using namespace std;// problemint N;double matr[MAX_N][MAX_N];// recorddouble free_line[MAX_N];void cal () &#123; matr[N][N + 1] /= matr[N][N]; for(int i = N - 1;i &gt; 0; --i) &#123; // 处理每一行 double sum = 0; for(int j = i + 1; j &lt;= N; ++j) &#123; sum += matr[i][j] * matr[j][N + 1]; //printf("%lf %lf %lf\n", matr[i][j], matr[j][N + 1], sum); &#125; matr[i][N + 1] = (matr[i][N + 1] - sum) / matr[i][i]; &#125; for(int i = 1;i &lt;= N; ++i) printf("%.2lf\n", matr[i][N + 1]);&#125;void solve () &#123; for(int tot = 1;tot &lt; N; ++tot) &#123; double stan = matr[tot][tot]; for(int i = tot + 1;i &lt;= N; ++i) &#123; //把tot列的元都消掉 if(matr[i][tot] == 0) continue; double now = matr[i][tot] / stan; for(int j = 1;j &lt;= N + 1; ++j) &#123; matr[i][j] -= matr[tot][j] * now; &#125; &#125; &#125; if(matr[N][N] == 0) &#123;printf("No Solution\n");exit(0);&#125; else cal();&#125;int main () &#123; scanf("%d", &amp;N); for(int i = 1;i &lt;= N; ++i) for(int j = 1;j &lt;= N + 1; ++j) &#123; scanf("%lf", &amp;matr[i][j]); if(matr[i][j] == 0) free_line[j]++; &#125; // special situation for(int i = 1;i &lt;= N; ++i) if(free_line[i] == N) &#123; printf("No Solution\n"); return 0; &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>洛谷</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first article]]></title>
    <url>%2F2017%2F12%2F29%2FMy-first-article%2F</url>
    <content type="text"><![CDATA[一年中最后几天才开始动手搭建这个blog真是有意思啊再见 2017!你好 2018!]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
