<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[atcoder_arc92_C - 2D Plane 2N Points]]></title>
    <url>%2F2018%2F03%2F18%2Fatcoder-arc92-C-2D-Plane-2N-Points%2F</url>
    <content type="text"><![CDATA[题面Problem StatementOn a two-dimensional plane, there are N red points and N blue points. The coordinates of the i-th red point are $(a_i,b_i)$, and the coordinates of the i-th blue point are $(c_i,d_i)$.A red point and a blue point can form a friendly pair when, the $x$-coordinate of the red point is smaller than that of the blue point, and the $y$-coordinate of the red point is also smaller than that of the blue point. At most how many friendly pairs can you form? Note that a point cannot belong to multiple pairs. ConstraintsAll input values are integers. $1≤N≤100$ $0≤a_i,b_i,c_i,d_i&lt;2N$ $a_1,a_2, \cdots ,a_N, c_1,c_2,\cdots,c_N$ are all different. $b_1,b_2,\cdots ,b_N,d_1,d_2,\cdots,d_N$ are all different. InputInput is given from Standard Input in the following format: N $a_1 b_1$ $a_2 b_2$ : $a_N b_N$ $c_1 d_1$ $c_2 d_2$ : $c_N d_N$ OutputPrint the maximum number of friendly pairs. Sample Input 1123456732 03 11 34 20 45 5 Sample Output 112 For example, you can pair (2,0) and (4,2), then (3,1) and (5,5). 题意解释给出N个红点N个蓝点，一个红点能与一个蓝点配对的条件是这个红点的x,y坐标都小于蓝点。 并且并且只能两两配对并且不能有重复的点。 问最多能够有多少点对满足要求。 题解其实就是将每个红点和与其满足条件的蓝点连边然后跑一遍二分图匹配就OK了。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define MAX_N 210using namespace std;int N;int coox[MAX_N], cooy[MAX_N];bool f[MAX_N][MAX_N], vis[MAX_N];int match[MAX_N];int res;bool dfs (int);int main () &#123; scanf("%d", &amp;N); for (int i = 1;i &lt;= 2 * N; ++i) scanf("%d%d", coox + i, cooy + i); for (int i = 1;i &lt;= N; ++i) for (int j = N + 1;j &lt;= 2 * N; ++j) if (coox[i] &lt; coox[j] &amp;&amp; cooy[i] &lt; cooy[j]) &#123; f[i][j - N] = true; &#125; for (int i = 1;i &lt;= N; ++i) &#123; memset(vis, false, sizeof(vis)); if (dfs(i)) res++; &#125; printf("%d\n", res); return 0;&#125;bool dfs (int x) &#123; for (int i = 1;i &lt;= N; ++i) &#123; if (!f[x][i] || vis[i]) continue; vis[i] = true; if (!match[i] || dfs(match[i])) &#123; match[i] = x; return true; &#125; &#125; return false;&#125;]]></content>
      <tags>
        <tag>atcoder</tag>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配-匈牙利算法入门]]></title>
    <url>%2F2018%2F03%2F18%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这里有一道板子题 一些定义首先是一些定义: 二分图：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。 我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。 举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此可以为同桌。是否可能让所有男孩和女孩两两配对，使得一个人坐(就是没有同桌)的人尽量少呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相可以为同桌的男孩/女孩可以配对儿？这就是最大匹配问题。 匈牙利算法基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）： 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。 匈牙利树其实匈牙利树感觉没有什么很大用处的样子？ 匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树： 这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。 以上来自dalao”renfei”的博客然后自己稍微做了一点改动。 顺便说一句：如果交到文章开头的网站评测后A了这道题最好还是和底下的程序对比一下看看实现方式是不是差不多(我本来match数组设的bool类型并且dfs手残打错了都A了) 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define MAX_N 1010using namespace std;int N, M, e;bool f[MAX_N][MAX_N], vis[MAX_N];int match[MAX_N];int res;bool dfs(int);int main () &#123; int u, v; scanf("%d%d%d", &amp;N, &amp;M, &amp;e); for (int i = 1;i &lt;= e; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); if (u &lt;= N &amp;&amp; v &lt;= M) f[u][v] = true; &#125; for (int i = 1;i &lt;= N; ++i) &#123; memset(vis, false, sizeof(vis)); if (dfs(i)) res++; &#125; printf("%d\n", res); return 0;&#125;bool dfs (int x) &#123; for (int i = 1;i &lt;= M; ++i) &#123; if (!f[x][i] || vis[i]) continue; vis[i] = true; if (!match[i] || dfs(match[i])) &#123; match[i] = x; return true; &#125; &#125; return false;&#125;]]></content>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prufer编码入门--[BZOJ1005]明明的烦恼]]></title>
    <url>%2F2018%2F03%2F16%2Fprufer%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8-BZOJ1005-%E6%98%8E%E6%98%8E%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[原题戳我 感觉这题做法还挺妙的。使用prufer编码来完成这道和树上统计有关的题。 对理解帮助很大的一篇博客 前排提示：这题需要prufer编码 以下转自上面那一篇博客： prufer编码树的prufer编码的性质： (1)树的prufer编码的实现 不断删除树中度数为1的最小序号的点，并输出与其相连的节点的序号，直至树中只有两个节点 (2)通过观察我们可以发现 任意一棵n节点的树都可唯一的用长度为n-2的prufer编码表示 度数为m的节点的序号在prufer编码中出现的次数为m-1 (3)怎样将prufer编码还原为一棵树？？ 从prufer编码的最前端开始扫描节点，设该节点序号为 u , 寻找不在prufer编码的最小序号且没有被标记的节点 v ， 连接u,v,并标记v，将u从prufer编码中删除。扫描下一节点。 这题怎么用prufer编码该题需要将树转化为prufer编码： n为树的节点数，d[]为各节点的度数，m为无限制度数的节点数。 然后设 $tot=\sum_{i=1}^{n} d[i]-1$ 所以要求在n-2大小的数组中插入tot个序号，共有$C_{n-2}^{tot}$种插法； 在tot个号排列中，插第一个节点的方法有$C_{tot}^{d_1-1}$种插法； 插第二个节点的方法有$C_{tot-(d_1-1)}^{d_2-1}$种插法； ……… 另外还有m各节点无度数限制，所以它们可任意排列在剩余的$n-2-tot$的空间中，排列方法总数为$m^{n-2-tot}$； 根据乘法原理： $$=\frac{(n-2)!\times m^{n-2-tot}}{(n-2-tot)!\times (d_1-1)!\times (d_2-1)!\times \cdots \times (d_n-1)!}$$ (这里的$d_i$能当作答案当且仅当$d_i$ &gt; 0) 然后就要高精度了…..但高精度除法太麻烦了，显而易见的排列组合一定是整数，所以可以进行质因数分解，再做一下相加减。 关于$n!$质因数分解有两种方法，第一种暴力分解，这里也讲第二种。 若p为质数，则n!可分解为 一个数$\times p^x$，其中$x=\lfloor \frac{n}{p} \rfloor + \lfloor \frac{n}{p^2} \rfloor + \cdots + \lfloor \frac{n}{p^t} \rfloor$且$p^t&lt;n$ 所以 $n!=p_1^{x_1}\times p_2^{x_2}\times p_3^{x_3} \times \cdots \times p_m^{x_m}$ UPD这里还讲一点和prufer编码有关的东西。 任意一个长度为$n-2$且序列中元素为$1～n$的序列都可以唯一的表示成一棵无根树。 n个节点，度分别为$d_1, d_2, d_3 \cdots d_n$的无根树共有$$\frac{(n-2)!}{(d_1-1)!\times (d_2-1)!\times (d_3-1)! \times\cdots \times (d_n-1)!}$$个 由两个唯一对应的性质，我们可以推出Cayley公式。一个完全图$K_n$有$n^{n-2}$棵生成树。 证明方法：生成树的个数就是元素为$1～n$的集合中取n-2个数排列的总方案数。 由于长度为$n-2$的序列每一个位置都可以放$1～n$中的任意一个数，所以总方案数显然是$n-2$个$n$相乘，即$n^{n-2}$ 我的程序那个。。。我好像用的暴力分解。。。还有。。。最近把emacs换成了四格缩进。贴上代码可能感觉稍微好一点，不会像之前一样窄了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define MAX_N 1005using namespace std;struct bignum &#123; int num[MAX_N * 100]; int len;&#125;res;int n, tot, m, cnt;int d[MAX_N], pri[MAX_N], num[MAX_N];void solve (int, int);void getprime ();inline bool jud (int);void mul (int);int main () &#123; getprime (); scanf("%d", &amp;n); if (n == 1) &#123; scanf("%d", &amp;d[1]); if (!d[1]) printf("1\n"); else printf("0\n"); return 0; &#125; for (int i = 1;i &lt;= n; ++i) &#123; scanf("%d", &amp;d[i]); if (!d[i]) &#123;printf("0\n");return 0;&#125; if (d[i] == -1) m++; else &#123;d[i]--; tot += d[i];&#125; &#125; if (tot &gt; n - 2) &#123;printf("0\n"); return 0;&#125; solve(n - 2, 1); solve(n - 2 - tot, -1); for (int i = 1;i &lt;= n; ++i) if (d[i] &gt; 0) solve (d[i], -1); res.num[1] = res.len = 1; for (int i = 1;i &lt;= cnt; ++i) while (num[i]--) mul(pri[i]); for (int i = 1;i &lt;= n - 2 - tot; ++i) mul(m); for (int i = res.len;i &gt; 0; --i) printf("%d", res.num[i]); printf("\n"); return 0;&#125;void mul (int x) &#123; for (int i = 1;i &lt;= res.len; ++i) res.num[i] *= x; for (int i = 1;i &lt;= res.len; ++i) res.num[i + 1] += res.num[i] / 10, res.num[i] %= 10; while (res.num[res.len + 1] &gt; 0) res.len++, res.num[res.len + 1] += res.num[res.len] / 10, res.num[res.len] %= 10;&#125;inline bool jud (int x) &#123; if (x == 2) return true; int sq = sqrt(x) + 1; for (int i = 2;i &lt;= sq; ++i) if (x % i == 0) return false; return true;&#125;void getprime () &#123; for (int i = 2;i &lt;= MAX_N; ++i) &#123; if (jud (i)) pri[++cnt] = i; &#125;&#125;void solve (int a, int f) &#123; for (int k = 1;k &lt;= a; ++k) &#123; int x = k; for (int i = 1;i &lt;= cnt; ++i) &#123; if (x &lt;= 1) break; while (x % pri[i] == 0) &#123;num[i] += f; x /= pri[i];&#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>树</tag>
        <tag>prufer编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学八题 --ByCZZ]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%85%AB%E9%A2%98ByCZZ%2F</url>
    <content type="text"><![CDATA[组合数学八题AUTHOR:CZZdalao A. 第一题基本就是来送分的，就相当于每个球可以放在随便一个盒子里，就是$m^n$就行 B. 这道题如果做出来了D题，就会非常简单，就是不同到相同的转化,也就是$dp[n][m]*m!$就可以求出答案了。 C.实际上我也不知道我是怎么水过的，这道题目就是D题中的$\sum_{k=1}^{m} dp[n][k]$啊！！，我暴力相加但是过了。what？ D. 首先看到这道题，第一反应应该是dp，设$dp[i][j]$表示在(前)j个盒子里放i个球的方案数，我们就可以把第j个盒子分成空和非空两种情况来考虑，这样就可以求出状态转移方程:$dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*j$ 然后就会发现数据范围不对。我们可以很快发现这个数列实际上就是一个裸的第二类斯特林数，我们用容斥原理就可以求出它的单点求法: $dp[n][m]=\frac{1}{m!}\times $ $ \sum{k=0}^{m} (-1)^k$$\times C{m}^{k}\times (m-k)^n $ ，这样就可以过掉了 E.与F题相似我们可以先把m个盒子里放一个球，然后在放剩下的n个球，于是按照F题的思路就可以很快算出:$C_{n-1}^{m+n-1}$ F. 我们可以转化一下思路，也就是在n-1个空中选取m-1个将这n个球分成m块，于是式子就出来啦：$C_{n-1}^{m-1}$ G. 看到数据范围就知道是一个dp，于是我们设$dp[i][j]$表示在(前)j个盒子里放i个球的方案数，那么我们按照空和非空两种情况可以推出状态转移方程:$dp[i][j]=dp[i][j-1]+dp[i-j][j]$ H. 看到题目和数据范围就知道跟G题有关系，我们可以考虑先把每一个盒子放一个球，然后剩下的$n-m$个球不就可以按照G题的方法进行递推了吗？这样就可以做出来了。 题目: (wei)评论: SysCon:orz%%%CZZdalao]]></content>
      <tags>
        <tag>数学</tag>
        <tag>他人文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初涉git]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%88%9D%E6%B6%89git%2F</url>
    <content type="text"><![CDATA[git是个好东西，它可以帮助你联系你的远程仓库并且干很多事。我认为，它要比本地的文件操作好很多。 在这里就随便讲讲一些比较简单的操作，有很多操作是git会提示你去做的。 一篇好文章 需要准备的事下载git… archlinux上使用sudo pacman -S git就可以。 其他版本linux一般也可以直接使用自己的包管理器直接安装git. 首先我们需要确定我们要干什么，git是需要一个本地和一个远程仓库的。 初始化本地仓库在本地文件夹上新建一个仓库。如mkdir gitlearning。 在终端中进入这个仓库cd gitlearning然后执行命令git init它就会提示你创建了一个新的空仓库。(实际上如果文件夹本来不空也可以直接创建仓库) 此时这个本地仓库已经初始化完成了。 你在这个仓库中的文件只需要一些命令就可以传到远程仓库。 初始化远程仓库为了方便，我们需要在远程仓库加入当前电脑的ssh_key。 使用命令ssh-keygen -t rsa -C &quot;YourEmail@example.com&quot; 此时你的主目录(~)应该已经有了一个隐藏文件夹.ssh，我们打开.ssh文件夹然后将id_rsa.pub文件中的内容copy下来，在github上的账户settings中AddSSHkey，将copy的内容放进去。 然后就OK了。 如何推送在本地仓库创建了一些文件后如何推送上去呢？ 首先保证仓库已经git init过。 接着与远程仓库对接一下 git remote add origin &#39;YourGitProjectURL&#39; git push -u origin master 然后使用git add ...命令，如果要将当前整个文件夹推送上去，就将’…’替换成’.’就行了，否则将’…’替换成你要推送的东西。 然后git commit -m &quot;...&quot;命令。 最后git push或git push origin master就行了。 如果其中出了错误，一般git会告诉你错在哪里以及如何解决。]]></content>
      <tags>
        <tag>杂谈</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ1741 Tree」树上点分治模板题]]></title>
    <url>%2F2018%2F03%2F01%2F%E3%80%8CPOJ1741-Tree%E3%80%8D%E7%82%B9%E5%88%86%E6%B2%BB%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[点分治基本想法点分治，就是按照点将某个问题分而治之。简单的来说，就是讲一个问题大事化小，小事化了。将数据规模较大的问题划分成一个个均等的子问题来解决。线性结构的点分治，经常是将当前考虑的区间分成两份，显然此时在中间会有一条分界线，但是我们如果想只是分别的处理左右两个区间的答案得到当前区间的答案显然是不行的。因为这样会漏掉跨过分界线的区间的答案。 所以我们先将跨过分界线但是在当前区间内的答案计算出来加入总答案。然后再分别处理两边区间的答案。这样才能做到不重复，不遗漏的计算答案。 POJ1741题意给出一颗大小为N的无根树，求出树上路径长度不大于k的路径条数。 POJ1741题解点分治的基本想法明确之后。可以来思考poj1741这一道裸题了。因为这是树，所以我们不能像处理区间问题一样单纯的只是每次找中点，此时我们应该思考，为什么线性结构上点分治要找中点？因为我们点分治的目的是将大数据划分成几乎均等大小的小数据来处理，那么在树上怎么样才能使接下来要处理的数据几乎均等呢？此时问题变成了求出当前树上存在的删掉后形成的子树规模均等的点了。这个点有一个名字，就是树的重心。很幸运的，可以使用树上DP来求出这一个点，求法很简单，在这里不用多说(https://www.baidu.com)。 因为要计算的是长度不小于k的路径条数，所以我们找到当前点的未搜索过的子树上(因为搜索过再搜就会搜回去，没这个必要，并且会死循环) 每个点到它的距离。然后按照距离排序，可以很轻松的求出合法方案数。 那么问题来了，如果在同一棵子树内出现了两个合法的点使得到顶点的距离之和不大于k呢？那么这个点对会在当前情况和处理那棵子树是都被算一遍！这违反了不重复不遗漏的规则！ 处理方法其实也很容易，只要将当前重心的每一棵子树内的合法答案算出来即可（注意，这里的合法答案是在加上到重心的距离后仍然满足距离不大于k的） 所以程序就很清晰了。(一开始TLE了结果还SB的加了个读入优化) 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define MAX_N 20005#define INF 2147483647using namespace std;int N, k;int head[MAX_N], nxt[2 * MAX_N + 1], to[2 * MAX_N + 1], dis[2 * MAX_N + 1], tmp;int root;int son[MAX_N], sz[MAX_N], sum;bool vis[MAX_N];int res;int deep[MAX_N], d[MAX_N];inline int read () &#123; int x = 0; char c;int w = 0; while (!isdigit(c)) w |= c == '-', c = getchar(); while (isdigit(c)) x *= 10, x += c - '0', c = getchar(); return w == 1 ? -x : x;&#125;void add_edge (int u, int v, int w) &#123; nxt[++tmp] = head[u]; head[u] = tmp; to[tmp] = v; dis[tmp] = w;&#125;void find_root(int x, int fa) &#123; son[x] = 1, sz[x] = 0; for (int i = head[x]; i; i = nxt[i]) &#123; int v = to[i]; if (v == fa || vis[v]) continue; find_root(v, x); son[x] += son[v]; sz[x] = max(sz[x], son[v]); &#125; sz[x] = max(sz[x], sum - son[x]); if (sz[x] &lt; sz[root]) root = x;&#125;void init () &#123; memset(head, 0, sizeof(head)); memset(nxt, 0, sizeof(nxt)); memset(to, 0, sizeof(to)); memset(dis, 0, sizeof(dis)); memset(vis, 0, sizeof(vis)); tmp = res = 0;&#125;void get_deep (int x, int fa) &#123; deep[++deep[0]] = d[x]; for (int i = head[x]; i; i = nxt[i]) &#123; int v = to[i], dist = dis[i]; if (v == fa || vis[v]) continue; d[v] = d[x] + dist; get_deep(v, x); &#125;&#125;int calc (int x, int v) &#123; d[x] = v, deep[0] = 0; get_deep(x, 0); sort(deep + 1, deep + deep[0] + 1); int l = 1, r = deep[0], sum = 0; while (l &lt; r) &#123; if(deep[l] + deep[r] &lt;= k) &#123;sum += r - l; l++;&#125; else r--; &#125; return sum;&#125;void solve (int x) &#123; res += calc(x, 0); vis[x] = true; for (int i = head[x]; i; i = nxt[i]) &#123; int v = to[i], dist = dis[i]; if (vis[v]) continue; res -= calc(v, dist); root = 0, sum = son[v]; find_root(v, 0); solve(root); &#125;&#125;int main () &#123; while (((N = read()) != 0) &amp;&amp; ((k = read()) != 0)) &#123; init(); int u, v, w; for (int i = 1;i &lt; N; ++i) &#123; u = read(), v = read(), w = read(); add_edge (u, v, w); add_edge (v, u, w); &#125; root = 0, sz[root] = INF, sum = N; find_root(1, 0); solve(root); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Manacher求最长回文子串」]]></title>
    <url>%2F2018%2F01%2F22%2F%E3%80%8CManacher%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E3%80%8D%2F</url>
    <content type="text"><![CDATA[原题戳我Manacher(马拉车)算法是用来求最长回文子串的。其实原理并不是很难，就是对暴力(Brute_Force)的优化。 问题描述最长回文子串问题，顾名思义是要求给定字符串的最长回文子串。回文串的定义就是以中心点为轴，两边的字符对称分布。 首先，讨论一下暴力算法。 Brute_Force算法对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有n^2个子串。这些子串的平均长度大约是n / 2，因此这个解法的时间复杂度是O(n^3)。 来想一下简单优化方法显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个，在每个位置上平均大约要进行\frac{n}{4}次字符比较，于是此算法的时间复杂度是O(n^2)。 最后就是看起来很厉害的Manacher算法对于一个比较长的字符串，O(n^2)的时间复杂度是难以接受的。还能再优化吗？ 先来看看解法2存在的缺陷。 由于回文串长度的奇偶性造成了不同性质的对称轴位置，解法2要对两种情况分别处理； 很多子串被重复多次访问，造成较差的时间效率。 首先我们应该解决长度奇偶性的问题，用Brute-Force方法的话，长度对称轴位置并不是一个很好确定的东西，是吧。 但是，通过小学数学可以知道，奇数加一为偶数，偶数加一为奇数，如果串长为奇数，就好处理得多了。所以就在串的间隙中插入一个不可能在题目中出现的字符(比如说#)，注意收首尾也要加上，此时加上的#个数为原串长加一，然后再加上原串长，一定为一个奇数加偶数的结果，就是一个奇数了，此时串长为奇数，对称轴好处理多了。举个例子:aba加上之后变成了:#a#b#a# 然后我们应该解决重复访问拉高复杂度的问题。我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组RL，用RL[i]表示以第i个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义RL[i]为第$i$个字符为对称轴的回文串的最右一个字符与字符i的距离。对于上面插入分隔符之后的两个串，可以得到RL数组：123456789char: # a # b # a # RL : 1 2 1 4 1 2 1RL-1: 0 1 0 3 0 1 0 i : 0 1 2 3 4 5 6char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 i : 0 1 2 3 4 5 6 7 8 通过观察可以发现，其实RL[i] - 1才是真正的回文串长 于是问题变成了，怎样高效地求的RL数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量MaxRight，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下MaxRight对应的回文串的对称轴所在的位置，记为pos，它们的位置关系如下。 当i在MaxRight左边可以用下图描述:我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以i为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到i关于pos的对称位置j，这个j对应的RL[j]我们是已经算过的。根据回文串的对称性，以i为对称轴的回文串和以j为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。(1)以j为对称轴的回文串比较短，短到像下图这样。这时我们知道RL[i]至少不会小于RL[j]，并且已经知道了部分的以i为中心的回文串，于是可以令RL[i]=RL[j]。但是以i为对称轴的回文串可能实际上更长，因此我们试着以i为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。(2)以j为对称轴的回文串很长，这么长：这时，我们只能确定，两条蓝线之间的部分（即不超过MaxRight的部分）是回文的，于是从这个长度开始，尝试以i为中心向左右两边扩展，直到左右两边字符不同，或者到达边界。 不论以上哪种情况，之后都要尝试更新MaxRight和pos，因为有可能得到更大的MaxRight。 具体操作如下:123令RL[i]=min(RL[2*pos-i], MaxRight-i)以i为中心扩展回文串，直到左右两边字符不同，或者到达边界。更新MaxRight和pos 2.当i在MaxRight的右边遇到这种情况，说明以i为对称轴的回文串还没有任何一个部分被访问过，于是只能从i的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新MaxRight和pos。 最后的最后的最后感谢 : 很有用的网站看完后不要吐槽我 最后的最后 程序 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_L 50000010#define INF 1 &lt;&lt; 31 - 1using namespace std;char s[MAX_L], s2[MAX_L];int rl[MAX_L], maxright, pos;int N, tot = 1;int res;int main () &#123; scanf("%s", s2 + 1); N = strlen(s2 + 1); for (int i = 1;i &lt;= N;i++, tot += 2) s[tot - 1] = '#', s[tot] = s2[i]; s[--tot] = '#'; maxright = pos = 0; fill(rl, rl + tot + 1, 0); for (int i = 0;i &lt;= tot; ++i) &#123; if (i &lt; maxright) rl[i] = min(maxright - i, rl[pos * 2 - i]); else rl[i] = 1; while (i - rl[i] &gt;= 0 &amp;&amp; i + rl[i] &lt;= tot &amp;&amp; (s[i + rl[i]] == s[i - rl[i]])) rl[i]++; if (rl[i] + i - 1&gt; maxright) &#123; maxright = rl[i] + i - 1; pos = i; &#125; res = max(res, rl[i]); &#125; printf("%d\n", res - 1); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2002」营业额统计 Treap模板题]]></title>
    <url>%2F2018%2F01%2F11%2F%E3%80%8CHNOI2002%E3%80%8D%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1-Treap%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原题戳我题目描述Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况： 当最小波动值越大时，就说明营业情况越不稳定。 而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。 第一天的最小波动值为第一天的营业额。 该天的最小波动值=min{|该天以前某一天的营业额-该天营业额|}。 输入输出格式输入格式：第一行为正整数n（n&lt;=32767） ，表示该公司从成立一直到现在的天数，接下来的n行每行有一个整数ai(|ai|&lt;=1000000) ，表示第i天公司的营业额，可能存在负数。 输出格式：输入输出样例输入样例#1：6512546 输出样例#1： 复制12 说明结果说明：5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12 题解一道十分裸的Treap，每次插入一个点之前求出它的前驱和后继，取和它距离较近的算出最小波动值即可。前驱 : 当前序列中小于该数的最大数后继 : 当前序列中大于该数的最小树 虽说时Treap模板，但还是要知道Treap怎么打才行吧。所以就简单的介绍一下:Treap其实是BST(二叉搜索树)的平衡版本。BST:保证每个结点的左子树所有结点都比它小，右子树上所有结点都比它大的树。或者可以看wikipedia的解释。但是仔细一想，是不是很多时候，都会出现，左子树一大串，几乎已经接近一条长链，但是右子树还只有一个点的情况呢？此时就应该将它平衡，如何平衡。可以给每一个点设置一个优先级(类似于代码中的变量rd)，接下来要做的就是保证建成的树既保证BST的性质，又保证堆的性质。当插入时，如果当前结点是之前没有创建过的，就新建一个节点。若没有，该要创建的点肯定在当前访问的点的子树上，那就在它的子树中建点。注意更新它的size(变量s)。当递归建子树完成后，判断子树和它的优先度，如果子树优先度比它小，就反转它和它的子树，这是为了维持堆的性质。下面的程序中维持的是小根堆(根结点比任何一棵子树都要小)，当然实际上随便大根堆还是小根堆都可以。好了就是这么简单。 为数不多的没用指针写的Treap对了，如果想看完整版Treap(带插入，删除，查找K-th的数，查找数的排名，查找前驱、后继)-&gt; 「代码仓库:Treap」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 缩进异常难看，请适应emacs#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#define MAX_N 50010#define INF 214748647#define MOD 999999using namespace std;struct point &#123; int w, rd, sz, re, l, r;&#125;p[MAX_N];int root, ans, tot;long long N, num[MAX_N], sum, pre_, nxt_;int rand_ () &#123; int a, b; //return a * b * (a - b) * (a + b) % MOD; return 1;&#125;void up (int x) &#123;p[x].sz = p[p[x].l].sz + p[p[x].r].sz + p[x].re;&#125;void r_rot (int &amp;x) &#123; int y = p[x].r; p[x].r = p[y].l; p[y].l = x; p[y].sz = p[x].sz; up(x); x = y;&#125;void l_rot (int &amp;x) &#123; int y = p[x].l; p[x].l = p[y].r; p[y].r = x; p[y].sz = p[x].sz; up(x); x = y;&#125;void ins (long long x, int&amp; k) &#123; if (k == 0) &#123; tot++; k = tot; p[k].w = x; p[k].sz = p[k].re = 1; p[k].rd = rand(); return; &#125; p[k].sz++; if (p[k].w == x) p[k].re++; else &#123; if (x &gt; p[k].w) &#123; ins(x, p[k].r); if (p[k].rd &gt; p[p[k].r].rd) r_rot(k); &#125; else &#123; ins(x, p[k].l); if (p[k].rd &gt; p[p[k].l].rd) l_rot(k); &#125; &#125;&#125;void pre (long long x, int k) &#123; if (k == 0) return; if (p[k].w &lt;= x) &#123; ans = k; pre(x, p[k].r); &#125; else pre(x, p[k].l);&#125;void nxt (long long x, int k) &#123; if (k == 0) return; if (p[k].w &gt;= x) &#123; ans = k; nxt(x, p[k].l); &#125; else nxt(x, p[k].r);&#125;int main () &#123; srand(0); scanf("%lld", &amp;N); p[0].w = INF; for (int i = 1;i &lt;= N; ++i) &#123; scanf("%lld", &amp;num[i]); &#125; sum = num[1]; ins(num[1], root); for (int i = 2;i &lt;= N; ++i) &#123; pre(num[i], root); int x = ans; nxt(num[i], root); sum += (long long)min(abs(num[i] - p[x].w), abs(p[ans].w - num[i])); ins(num[i], root); &#125; printf("%lld\n", sum); return 0;&#125;cpp]]></content>
      <tags>
        <tag>Treap</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2011」阿狸的打字机]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%8CNOI2011%E3%80%8D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[原题戳我题目背景阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。 题目描述打字机上只有28个按键，分别印有26个小写英文字母和’B’、’P’两个字母。经阿狸研究发现，这个打字机是这样工作的： ·输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。 ·按一下印有’B’的按键，打字机凹槽中最后一个字母会消失。 ·按一下印有’P’的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入aPaPBbP，纸上被打印的字符如下： a aa ab 我们把纸上打印出来的字符串从1开始顺序编号，一直到n。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数(x,y)（其中1≤x,y≤n），打字机会显示第x个打印的字符串在第y个打印的字符串中出现了多少次。 阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？ ### 输入输出格式 输入格式：输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。 第二行包含一个整数m，表示询问个数。 接下来m行描述所有由小键盘输入的询问。其中第i行包含两个整数x, y，表示第i个询问为(x, y)。 输出格式：输出m行，其中第i行包含一个整数，表示第i个询问的答案。 输入输出样例输入样例#1：aPaPBbP31 21 32 3 输出样例#1：210 说明数据范围:对于100%的数据，n&lt;=100000,m&lt;=100000,第一行总长度&lt;=100000。 题解这题当时拿到也没什么想法，跪了两天加上Dra大神的提示(大法师(DFS)序+AC自动机+线段树)还是站起来了。其实就是根据题目输入的特性来对AC自动机做一点优化首先，想到的可能就是这是一道很明显的多个模式串匹配多个文本串的题目，而且模式串和文本串集合是一样的。但是，如果暴力的一个个匹配每一个输入的串，复杂度可能要达到整个打印出的字符串总长度看上取似乎是10^5，但是如果一直输入一个串然后不停的PBPBPBPBP可能会达到10^9级别。(也可能没算对)所以我们需要进行一些改进。 从题目可知，只需按照输入数据模拟就可以成功的建出一棵(颗)Trie(da)树(baicai)这是简单的输入，接着我们造出fail数组顺便建一颗fail树。此时到了我们需要进行进一步处理的地方。由于题目输入的特性，Trie树是根据一步步的模拟进行的。所以如果一个字符串在另一个字符串中出现，那在模拟中也会走到这个字符串的结点。所以只需模拟栈，输入该字符进栈(即输入到Trie树中加入节点)就将贡献+1若出栈(即将这个字符串进行’B’操作)就将贡献-1(因为此时它已经不在了)等到需要结算时(正在进行’P’操作)，就将关于它的询问都进行一次查找。从AC自动机简单版求出现次数博客中可以知道将待求出现次数的结点所在fail树的子树(包括自己)贡献总和就可以求出出现次数了。看完上面的文字，肯定已经都想出来了–还有地方可以优化!正确对每个结点的贡献+1, -1(注意是在fail树中进行的操作)以及对fail树进行子树遍历结算时，不都是像极了单点修改区间查询吗？只不过时fail树看起来不满足区间修改而已。但是可以注意到，再一棵树的DFS序中，一个结点和它的子树肯定是在一段连续区间上的，所以我们可以将fail树转化成DFS序进行修改和查询。然后再思考一遍，理清头绪，就可以开始打了。 吐槽蒟蒻不禁吐槽程序真难打。我一开始还以为进行’B’操作时需要删掉在Trie树上的点，结果还用个stack装结构体来读入。结果Dra后来说不用删点。但我还是不太知道为什么不用(蒟蒻太水还没想出来) 程序 (可能还比较清晰吧)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 100100using namespace std;struct str &#123; char s; bool book;&#125;;stack&lt;str&gt; stk;char t[MAX_N];int ch[MAX_N][30], sz = 1, fa[MAX_N];int strin[MAX_N], strsum;int M;int head[MAX_N], to[MAX_N], nxt[MAX_N], ttop;int fail[MAX_N];int fail_head[MAX_N], fail_to[MAX_N], fail_nxt[MAX_N], x[MAX_N], failtop;int totans[MAX_N];int bit[MAX_N * 2];int idx (char c) &#123;return c - 'a';&#125;void Read () &#123; int len_ = strlen(t); int u = 0; for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(t[i]); if (t[i] == 'P') &#123; stk.top().book = true; strin[++strsum] = u; &#125; else if (t[i] == 'B') &#123; if (stk.top().book == true) &#123; //当前删除的是合法的点，不用烧边，把正确标记移至下一个字符 stk.pop(); if (!stk.empty()) stk.top().book = true; u = fa[u]; //向上到上一层点 &#125; else &#123; ch[fa[u]][stk.top().s - 'a'] = 0; //它的上一层向它无边(烧边) stk.pop(); u = fa[u]; sz--; //这条边不算数 &#125; &#125; else &#123; if (ch[u][c]) &#123;u = ch[u][c];continue;&#125; ch[u][c] = sz++; //加一条边 fa[sz - 1] = u; //记录它的上层节点编号，以便于删除时向上 stk.push((str)&#123;t[i], false&#125;); //将当前字符串压入栈中，初始值为false因为当时还没有P是一个不合法的值 u = ch[u][c]; //跳到下一个点 &#125; &#125;&#125;void fail_AddEdge (int _from_, int _to_) &#123; fail_nxt[++failtop] = fail_head[_from_]; fail_head[_from_] = failtop; fail_to[failtop] = _to_; &#125;void getfail () &#123; queue&lt;int&gt; q; fail[0] = 0; for (int i = 0;i &lt; 26; ++i) if (ch[0][i]) &#123; //AddEdge fail_AddEdge(0, ch[0][i]); q.push(ch[0][i]); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int c = 0;c &lt; 26; ++c) &#123; if (!ch[u][c]) continue; q.push(ch[u][c]); int v = fail[u]; while (v &amp;&amp; !ch[v][c]) v = fail[v]; fail[ch[u][c]] = ch[v][c]; //AddEdge int _from_ = ch[v][c], _to_ = ch[u][c]; fail_AddEdge(_from_, _to_); &#125; &#125;&#125;int tot;int l[MAX_N], r[MAX_N], order_[MAX_N], iorder_[MAX_N];void get_dfs_order (int x, int fa) &#123; l[x] = ++tot; order_[tot] = x; iorder_[x] = tot; for (int now = fail_head[x]; now; now = fail_nxt[now]) &#123; int _to = fail_to[now]; if (_to == fa) continue; get_dfs_order(_to, x); &#125; r[x] = tot;&#125;int bit_find (int i) &#123; int s = 0; while (i &gt; 0) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void bit_add (int i, int x) &#123; while (i &lt;= tot) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;void rebuild () &#123; int pt = 0, u = 0; int len_ = strlen(t); for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(t[i]); if (t[i] == 'P') &#123; ++pt; for (int i = head[pt]; i; i = nxt[i]) &#123; int now = strin[to[i]]; totans[x[i]] = bit_find (r[now]) - bit_find(l[now] - 1); &#125; &#125; else if (t[i] == 'B') &#123; bit_add(l[u], -1); u = fa[u]; &#125; else &#123; bit_add(l[ch[u][c]], 1); u = ch[u][c]; &#125; &#125;&#125;int main () &#123; scanf("%s", t); Read(); getfail(); scanf("%d", &amp;M); int _book_[MAX_N]; memset(_book_, 0, sizeof(_book_)); for (int i = 1;i &lt;= M; ++i) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); _book_[b] = 1; nxt[++ttop] = head[b]; head[b] = ttop; to[ttop] = a; x[ttop] = i; &#125; get_dfs_order(0, 0); rebuild(); for (int i = 1;i &lt;= M; ++i) printf("%d\n", totans[i]); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ'Hello2018'-A」奴隶主的游戏]]></title>
    <url>%2F2018%2F01%2F03%2F%E3%80%8CLOJ-Hello2018-A%E3%80%8D%E5%A5%B4%E9%9A%B6%E4%B8%BB%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目题目描述奴隶主家的公告：欢迎和我玩数独游戏，赢了你将获得万贯家财，输了 …… 而你正好看到这则公告 数独游戏的规则是这样的： 初始的时候有一个 n 阶数独（n 阶数独即边长为 n^2 的分成 n^2 个 n×n 区域的方格，下图为 4 阶数独），并且已经填了 k 个格子，现在两个人轮流在空格子中填数（当然是你先填啦），每次填完需保证局面合法（合法即要求每个人填完后同行同列同区域不能出现相同数字并且填的数字是 [1,n^2] 中的整数），能填必须填，不能填者输。 现在你要确定你（先手）是否有必胜策略，以免鲁莽输掉游戏沦为奴隶。 输入格式第一行一个整数 T 表示有 T 组数据。 对于每组数据第一行两个整数 n,k。 接下来有 kkk 行，每行三个整数 x,y,z 表示第 x 行 y 列填了数字 z。保证填的格子不重复，且已经填好的数字合法。 输出格式对于每组数据输出一个字符串：YES 表示有必胜策略，NO 表示没有必胜策略。 样例注意：样例中有 1≤n&lt;4 的情况，这只是为了便于解释样例及说明游戏规则，在实际的测试数据中保证 n≥4。 样例输入 111 0 样例输出 1YES 样例解释 1初始局面是一个 1x1的方块并且没有填，你只要填上 1 就可获胜。 样例输入 214 29 13 19 16 2 样例输出 2NO 样例解释 2输入即为上图填了 1 和 2 后的局面。 数据范围与提示对于所有数据，4​≤n≤5, 0≤k≤2, 1≤T≤20, 1≤x, y, z≤n^2。 保证填的格子不重复，且已经填好的数字合法。 题解其实题目很简单， 找规律就可以以下就找出来。你想想自己应该怎么样才能赢，也就是想想最优策略。在一个2x2 x 2x2 的小方格中和自己玩了一盘后，我大概知道怎么样才能获胜了。可以把这个数独想象成一个棋盘。我们一定可以找到棋盘的中心，对方每下一步，你就下一步相对于棋盘的中心与他所下棋对称的。这样只需考虑谁最后会下完整盘棋的最后一个子，他就赢了。然后只要考虑棋盘中可下空位的奇偶性。代码也就出来了，非常短。(十足的水题)123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int T, N, K;int main () &#123; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;N, &amp;K); int sum = N * N * N * N; int x, y, z; for (int i = 1;i &lt;= K; ++i) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); &#125; int res = sum - K; if (res % 2 == 0) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>LOJ</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>LOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3808AC自动机简单版]]></title>
    <url>%2F2017%2F12%2F30%2Fluogu3808AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目原题戳我 题目背景这是一道简单的AC自动机模板题。 用于检测正确性以及算法常数。 为了防止卡OJ，在保证正确的基础上只有两组数据，请不要恶意提交。 管理员提示：本题数据内有重复的单词，且重复单词应该计算多次，请各位注意 题目描述给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。 输入输出格式输入格式：第一行一个n，表示模式串个数； 下面n行每行一个模式串； 下面一行一个文本串。 输出格式：一个数表示答案 先简单介绍一下AC自动机Aho-Corasick(简称AC)自动机是解决多个模板匹配一个文本串的算法.同(xiao)学(xue)们(sheng)都知道KMP算法是解决一个模式串匹配一个文本串的算法。但是如果模式串有很多个，KMP就不太合适了，因为每查找一次文本串都要匹配一次模式串，怎么样可以直接一次遍历呢？那就需要用AC自动机了 大概思路其实AC自动机和KMP算法有一定的相似度。KMP的状态转移图是线性的(一个)字符串加上失配边组成的。所以思考怎样把多个字符串整合到一起。那就用一个Trie树就可以了，Trie树可以将多个字符串整合到一个图中以便于查找。 下图1.1为{he,she,his,hers}的Trie 1.2为对应的AC自动机，虚线表示它的fail值所以构造好Trie树后，匹配算法和KMP几乎一样。 需要提及的在Trie树中把文本串走过一遍之后，怎么才能求出每个匹配串的出现次数？我们需要建一个fail树每个子节点的父节点就是父节点在Trie树中的所代表节点的fail指向的节点e.g.若按图中所示Trie树建fail树，则最右端(‘hers’中的)’s’节点和最上端(‘his’中的)’s’节点的父节点是最下端(‘she’中的)’s’节点在在Trie树中匹配文本串时，肯定会有一条路径，我们就把路径上的节点都设置一个代表值val[],每个访问到的节点都val[i]++。最后用DFS查找每个单词在Trie树中对应的(尾端)节点 在fail树中对应的子树上所有点（包括自己）的val[]总和。证明略过。 程序(查找所有模式串出现次数总和)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAX_L 1000006#define MAX_N 500#define INF 2147483647using namespace std;int N;char s[MAX_L];int s_[MAX_L];char t[MAX_L];struct ac &#123; int ch[MAX_L][30]; int val[MAX_L]; int fail[MAX_L]; int ifail[MAX_L][30]; int sz = 1; int toti = 0; int idx(char c) &#123;return c - 'a';&#125; void insert (char* s, int t) &#123; int u = 0, len_ = strlen(s); for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); ch[u][c] = sz++; &#125; fail[ch[u][c]] = u; u = ch[u][c]; &#125; s_[t] = u; &#125; void getfail() &#123; queue&lt;int&gt; Q; fail[0] = 0; for (int i = 0;i &lt; 26; ++i) &#123; if (ch[0][i]) &#123; Q.push(ch[0][i]); &#125; &#125; while (!Q.empty()) &#123; int x = Q.front();Q.pop(); for (int i = 0;i &lt; 26; ++i) &#123; int u = ch[x][i]; if (!u) continue; Q.push(u); int v = fail[x]; while (v &amp;&amp; !ch[v][i]) v = fail[v]; fail[u] = ch[v][i]; ifail[fail[u]][i] = u; &#125; &#125; &#125; void search (char* t) &#123; int len_ = strlen(t); int k = 0; for (toti = 0; toti &lt; len_; ++toti) &#123; int c = idx(t[toti]); while (k &amp;&amp; !ch[k][c]) k = fail[k]; k = ch[k][c]; val[k]++; &#125; &#125; int dfs(int x) &#123; int sum = 0; for (int i = 0;i &lt; 26; ++i) if (ifail[x][i]) sum++; if (sum == 0) return val[x]; sum = val[x]; for (int i = 0;i &lt; 26; ++i) &#123; if (!ifail[x][i]) continue; sum += dfs(ifail[x][i]); &#125; return sum; &#125; int find (int u) &#123; int res = dfs(u); return res; &#125;&#125;;ac aho;int main () &#123; scanf("%d", &amp;N); for (int i = 0;i &lt; N; ++i) &#123; scanf("%s", s); aho.insert(s, i); &#125; aho.getfail(); scanf("%s", t); aho.search(t); int res = 0; for (int i = 0;i &lt; N; ++i) &#123; res += aho.find(s_[i]) &gt; 0 ? 1 : 0; &#125; printf("%d\n", res); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3976AC自动机加强版]]></title>
    <url>%2F2017%2F12%2F30%2Fluogu3976AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目https://www.luogu.org/problemnew/show/P3796 题目描述有N个由小写字母组成的模式串以及一个文本串T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串T中出现的次数最多。 输入输出格式输入格式：输入含多组数据。 每组数据的第一行为一个正整数N，表示共有N个模式串，1≤N≤150。 接下去N行，每行一个长度小于等于70的模式串。下一行是一个长度小于等于10^6的文本串T。 输入结束标志为N=0。 输出格式：对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。 简述这一个其实和简单版差不多，就是多了多组数据，然后查询的是最大值。就只是稍微做一点改动，然后记得init。这题程序其实不是特别对的，因为我是针对的某些小一点的数据初始化的。代码比简单版长一些。可以参考简单版的博客:https://sysconkonn.github.io/2017/12/30/luogu3808AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95%E7%89%88/ 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAX_L 1000006#define MAX_N 160#define INF 2147483647using namespace std;int N;char s[MAX_N][100];int s_[150];char t[MAX_L];struct ac &#123; int ch[MAX_L][30]; int val[MAX_L]; int fail[MAX_L]; int ifail[MAX_L][30]; int sz = 1; int toti = 0; int idx(char c) &#123;return c - 'a';&#125; void init() &#123; memset(ch, 0, sizeof(ch)); &#125; void insert (char* s, int t) &#123; int u = 0, len_ = strlen(s); for (int i = 0;i &lt; len_; ++i) &#123; int c = idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); ch[u][c] = sz++; &#125; fail[ch[u][c]] = u; u = ch[u][c]; &#125; s_[t] = u; &#125; void getfail() &#123; queue&lt;int&gt; Q; fail[0] = 0; for (int i = 0;i &lt; 26; ++i) &#123; if (ch[0][i]) &#123; Q.push(ch[0][i]); &#125; &#125; while (!Q.empty()) &#123; int x = Q.front();Q.pop(); for (int i = 0;i &lt; 26; ++i) &#123; int u = ch[x][i]; if (!u) continue; Q.push(u); int v = fail[x]; while (v &amp;&amp; !ch[v][i]) v = fail[v]; fail[u] = ch[v][i]; ifail[fail[u]][i] = u; //printf("%d %c : %d\n", u, i + 'a' , fail[u]); &#125; &#125; &#125; void search (char* t) &#123; int len_ = strlen(t); int k = 0; for (toti = 0; toti &lt; len_; ++toti) &#123; int c = idx(t[toti]); while (k &amp;&amp; !ch[k][c]) k = fail[k]; k = ch[k][c]; val[k]++; &#125; &#125; int dfs(int x) &#123; int sum = 0; for (int i = 0;i &lt; 26; ++i) if (ifail[x][i]) sum++; if (sum == 0) return val[x]; sum = val[x]; for (int i = 0;i &lt; 26; ++i) &#123; if (!ifail[x][i]) continue; sum += dfs(ifail[x][i]); &#125; return sum; &#125; int find (int u) &#123; int res = dfs(u); return res; &#125;&#125;;ac aho;int ans = 0;int main () &#123; while (1) &#123; scanf("%d", &amp;N); if (N == 0) break; if (N &lt;= 20) aho.init(); for (int i = 0;i &lt; N; ++i) &#123; scanf("%s", s[i]); aho.insert(s[i], i); &#125; aho.getfail(); scanf("%s", t); aho.search(t); int res = 0; int _s[150]; for (int i = 0;i &lt; N; ++i) &#123; _s[i] = aho.find(s_[i]); res = max(_s[i], res); &#125; printf("%d\n", res); for (int i = 0;i &lt; N; ++i) &#123; if (_s[i] == res) printf("%s\n", s[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈KMP算法]]></title>
    <url>%2F2017%2F12%2F29%2F%E6%B5%85%E8%B0%88KMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单介绍明天要学Aho-Corasick(AC)自动机了,今天再复习一下KMP，可能有助于明天的听课吧。KMP算法，是在一个字符串(源串)s中匹配一个模式串t出现位置的算法。什么叫出现?就是s[j] = t[1], s[j+1] = t[2], …, s[j+n-1] = t[n]如果用朴素算法(小学生都知道)的话最坏时复杂度会达到O(m(n-1))而KMP算法只需O(m+n)在这里就不说多了，因为毕竟只是当AC自动机的铺垫下面这张图是KMP的精髓: 假定在匹配中，正在比较的文本串位置和模板串abbaaba最后一个字符不符合（失配），这是朴素算法会将模板串右移一位，继续比较，但是kmp不这样做，kmp认为既然’!!’位置已经比较过，应该可以利用模板串本身属性判断出右移一位不能匹配，同理，右移两位或者三位也不行，但是右移四位是有可能的。这个时候，需要比较 ‘*’处的字符和abbaaba的第三个字符。 上图下面那个链状图就是一个状态机，其中编号为i的节点表示已经匹配了i个字符，匹配开始是0，如果成功匹配则+1，失配时‘沿着失配边走’，如果在状态6处失配，应转到状态2.为了方便，这里使用失配函数f[i]表示状态i失配时应转移到的新状态，要特别注意的是f[0]=0。 如果没有看懂可以看看下面这篇CSDN博客，感觉挺有帮助的: http://blog.csdn.net/to_be_better/article/details/49086075程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX_N 1000001using namespace std;char s[MAX_N], t[MAX_N];void getNext (int len_, int maxl[]) &#123; for(int i = 1, k = 0;i &lt; len_; ++i) &#123; while(k &gt; 0 &amp;&amp; t[i] != t[k]) k = maxl[k - 1]; if(t[k] == t[i]) k++; maxl[i] = k; &#125;&#125;void print (int i, int j) &#123; printf("%d\n", i - j + 1);&#125;void search (int len_s, int len_t, int maxl[]) &#123; for(int i = 0, j = 0;i &lt; len_s; ++i) &#123; while(j &gt; 0 &amp;&amp; s[i] != t[j]) j = maxl[j - 1]; if(s[i] == t[j]) j++; if(j == len_t) print(i, j - 1); &#125;&#125;int main () &#123; scanf("%s", s); scanf("%s", t); int len1 = strlen(s), len2 = strlen(t); int maxl[len1]; memset(maxl, 0, sizeof(maxl)); //获得匹配字符串t的next数组 getNext(len2, maxl); search(len1, len2, maxl); for(int i = 0;i &lt; len2; ++i) printf("%d ", maxl[i]); printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468区间修改区间查询模板题]]></title>
    <url>%2F2017%2F12%2F29%2Fpoj3468%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目A Simple Problem with IntegersTime Limit: 5000MS Memory Limit: 131072K Case Time Limit: 2000MSDescriptionYou have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. “C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000. “Q a b” means querying the sum of Aa, Aa+1, … , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 Sample Output455915 HintThe sums may exceed the range of 32-bit integers. 题解就是节约一点时间，不要访问的就懒得加下去了，弄一个tag数组，如果tag[i]不为0，就说明它的子树和以下所有节点都应该加上tag[i],重要的一点是你需要保证每一个所到达的节点都是正确的，所以你在访问到某个节点(它已经是正确的了)，你需要push_down，这样才可以保证其下面的两个直接子节点都是正确的。总的来说：就是保证三点: 到达的每个节点当前的值是正确的 每个节点的tag值都是它和底下所有节点都需要加上的 每访问某个节点都要push_down(把tag[]里的值加到子节点)使得子节点的值正确. 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include #include #include #include #include #define MAX_N 1000010typedef long long ll;using namespace std;int N, Q;ll dat[MAX_N * 4], tag[MAX_N * 4], p[MAX_N];long long mk_tree(int l, int r, int now) &#123; if (l == r) return dat[now] = p[l]; return dat[now] = mk_tree(l, (l + r) / 2, now * 2) + mk_tree((l + r) / 2 + 1, r, now * 2 + 1);&#125;void push_down (int k, int l, int r, int val) &#123; int l1 = l, l2 = (l + r) / 2 + 1, r1 = (l + r) / 2, r2 = r; tag[k * 2] += val; tag[k * 2 + 1] += val; dat[k * 2] += 1LL * val * (r1 - l1 + 1); dat[k * 2 + 1] += 1LL * val * (r2 - l2 + 1); tag[k] = 0;&#125;void add(int a, int b, int x, int k, int l, int r) &#123; if (r &lt; a || b &lt; l) return; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; tag[k] += x; dat[k] += 1LL * x * (r - l + 1); push_down(k, l, r, tag[k]); return; &#125; else if (a &lt;= r &amp;&amp; l &lt;= b) &#123; //tag[k] += x; dat[k] += 1LL * (min(b, r) - max(a, l) + 1) * x; push_down(k, l, r, tag[k]); add(a, b, x, k * 2, l, (l + r) / 2); add(a, b, x, k * 2 + 1, (l + r) / 2 + 1, r); &#125;&#125;long long sum(int a, int b, int k, int l, int r) &#123; if (r &lt; a || b &lt; l) return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) &#123; return dat[k]; &#125; else if (a &lt;= r &amp;&amp; l &lt;= b) &#123; push_down(k, l, r, tag[k]); return sum(a, b, k * 2, l, (l + r) / 2) + sum(a, b, k * 2 + 1, (l + r) / 2 + 1, r); &#125;&#125;int main () &#123; while (~scanf("%d%d", &amp;N, &amp;Q)) &#123; memset(dat, 0, sizeof(dat)); memset(tag, 0, sizeof(tag)); memset(p, 0, sizeof(p)); for (int i = 1;i &lt;= N; ++i) scanf("%lld", &amp;p[i]); dat[1] = mk_tree(1, N, 1); char s[6]; for (int i = 1;i &lt;= Q; ++i) &#123; getchar(); scanf("%s", s); if (s[0] == 'C') &#123; int l, r, d; scanf("%d%d%d", &amp;l, &amp;r, &amp;d); add(l, r, d, 1, 1, N); &#125; else if (s[0] == 'Q') &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%lld\n", sum(l, r, 1, 1, N)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1754I Hate It题解-线段树模板题]]></title>
    <url>%2F2017%2F12%2F29%2FHDU1754I-Hate-It%E9%A2%98%E8%A7%A3-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[十分简单的单点修改区间+查询最大值。 线段树原理就不解释了，反正都知道。贴一个图助于理解好了。 因为太简单所以直接上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include #include #include #include #define MAX_N 300010#define MAX_Q 1000040#define INF 2147483647using namespace std;int N, Q;long long ST_Max[MAX_N * 4 + 1];long long H[MAX_N];int top = 0;int pos[MAX_N], max_;long long _max(long long a, long long b) &#123; return a &lt; b ? b : a;&#125;int AT_Max(int l, int r, int now) &#123; max_ = _max(max_, now); if(l == r) &#123;pos[l] = now;return ST_Max[now] = H[l];&#125; return ST_Max[now] = _max(AT_Max(l, (l + r) / 2, now * 2), AT_Max((l + r) / 2 + 1, r, now * 2 + 1));&#125;long long find_Max(int l, int r, int lsum, int rsum, int now) &#123; if(l &gt; rsum || r &lt; lsum) return -INF; if(l &gt;= lsum &amp;&amp; r &lt;= rsum) return ST_Max[now]; return _max(find_Max(l, (l + r) / 2, lsum, rsum, now * 2), find_Max((l + r) / 2 + 1, r, lsum, rsum, now * 2 + 1));&#125;void cag (int x, int a) &#123; x = pos[x]; ST_Max[x] = a; while (x &gt; 0) &#123; //printf("%d\n", x); x = (x ^ 1) / 2; ST_Max[x] = _max(ST_Max[x * 2], ST_Max[x * 2 + 1]); &#125;&#125;void find_() &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); long long res = find_Max(1, N, l, r, 1); printf("%lld\n", res);&#125;void change() &#123; int x, a; scanf("%d%d", &amp;x, &amp;a); cag(x, a);&#125;void print() &#123; int sum = 1; for (int i = 1;sum &lt;= max_; ++i) &#123; for (int j = 1;j &lt;= pow(2, i - 1); ++j) printf("%lld ", ST_Max[sum++]); printf("\n"); &#125;&#125;int main() &#123; while(scanf("%d%d", &amp;N, &amp;Q) == 2) &#123; memset(H, 0, sizeof(H)); memset(ST_Max, 0, sizeof(ST_Max)); memset(pos, 0, sizeof(pos)); for(int i = 1;i &lt;= N; i++) scanf("%lld", &amp;H[i]); ST_Max[1] = AT_Max(1, N, 1); for (int i = 1;i &lt;= Q; ++i) &#123; char c[20]; scanf("%s", c); //print(); if (c[0] == 'Q') find_(); else change(); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>HDU</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3376最大流模板题]]></title>
    <url>%2F2017%2F12%2F29%2Fluogu3376%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[不解释，直接上代码(这一份写的不好，不正规，并不想多加解释了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 10001#define INF 2147483647using namespace std;struct Edge &#123; int to, cap; Edge(int v, int d):to(v), cap(d) &#123;&#125;&#125;;vector &lt;Edge&gt; edges[MAX_N];int N, M;int s, t;int dep[MAX_N], idep[MAX_N];void bfs (int s) &#123; memset(dep, -1, sizeof(dep)); memset(idep, 0, sizeof(idep)); queue&lt;int&gt; Q; while (!Q.empty()) Q.pop(); dep[s] = 0; idep[0]++; Q.push(s); while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (int i = 0;i &lt; edges[now].size(); ++i) &#123; Edge&amp; e = edges[now][i]; if(e.cap &gt; 0 &amp;&amp; dep[e.to] &lt; 0) &#123; dep[e.to] = dep[now] + 1; idep[dep[e.to]]++; Q.push(e.to); &#125; &#125; &#125;&#125;int find_ (int x, int u) &#123; for (int i = 0;i &lt; edges[u].size(); ++i) if(edges[u][i].to == x) return i;&#125;int dfs (int now, int flow) &#123; //printf("OK"); if(now == t) return flow; for(int i = 0;i &lt; edges[now].size(); ++i) &#123; Edge&amp; e = edges[now][i]; if((dep[e.to] == dep[now] + 1) &amp;&amp; (e.cap &gt; 0)) &#123; int f = dfs(e.to, min(flow, e.cap)); if(f &gt; 0) &#123; e.cap -= f; edges[e.to][find_(now, e.to)].cap += f; return f; &#125; &#125; &#125; return 0;&#125;void print (int out) &#123; printf("%d\n", out); exit(0);&#125;void add_ (int u, int v, int cap) &#123; edges[u].push_back(Edge(v, cap)); edges[v].push_back(Edge(u, 0));&#125;void db (int);int check () &#123; bool book = false; int sum = 0; for (int i = 0;sum &lt; N &amp;&amp; i &lt; N; ++i) &#123; if(idep[i] == 0) book = true; sum += idep[i]; &#125; if (book == true) return 1; return 0;&#125;int main () &#123; scanf("%d%d", &amp;N, &amp;M); scanf("%d%d", &amp;s, &amp;t); for(int i = 1;i &lt;= M; ++i) &#123; int u, v, cap; scanf("%d%d%d", &amp;u, &amp;v, &amp;cap); add_(u, v, cap); &#125; int res = 0; int d = 0; for (;;) &#123; bfs(s); if(dep[t] &lt; 0) print(res); while(d = dfs(s, INF)) res += d; &#125; print(res); return 0;&#125;void db (int res) &#123; printf("%d\n", res); for(int i = 1;i &lt;= N; ++i) printf("%d ", dep[i]); printf("\n"); for(int i = 0;i &lt; N; ++i) printf("%d ", idep[i]); printf("\n"); int sum = 0; for(int i = 0;sum &lt; N &amp;&amp; i &lt; N; ++i) &#123; sum += idep[i]; printf("%d %d\n", i, sum); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1830题解-开关问题]]></title>
    <url>%2F2017%2F12%2F29%2Fpoj1830%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开关问题Time Limit: 1000MS Memory Limit: 30000K Description有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序） Input输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &lt; N &lt; 29） 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。 Output如果有可行方法，输出总数，否则输出“Oh,it’s impossible~!!” 不包括引号 Sample Input230 0 01 1 11 21 32 12 33 13 20 030 0 01 0 11 22 10 0 Sample Output4Oh,it’s impossible~!!Hint 第一组数据的说明：一共以下四种方法： 操作开关1 操作开关2 操作开关3 操作开关1、2、3 （不记顺序） 题解这题其实挺水的，但是可能由于是晚上想的而且没有特别开动脑筋吧，结果做完之后WA了7还是8次， 当时每次提交我的心都在滴血，最后调试了1个多小时后，终于发现是求开头要替换的那个求错了， (说不清楚，反正也不重要了)，果然要打代码打标准啊。 怎么做呢? 就是一个简单的高斯消元，首先对于每个灯肯定只有开着或关着，按了或者没按，并且结果(也就是最后灯是开着还是关着)是每次可影响它的灯按了之后加上自己的影响的结果， 观察一下可以发现，如果每个灯按了记作1，不然记作0，每个灯受的影响异或起来就是结果。 举个例子: 设一个灯受了3个灯的影响 ，则因为1^1^1=1，它的结果是1，也就是亮着. 因为有N个灯，就造一个N*N的方阵A，第i行第j个位置表示灯j对灯i有没有影响(有就是1，否则0) 再造一个N的数组存结果，开了就是1，否则0. 最后高斯消元，就是把消系数改成若两个系数不同就把第二排和第一排异或一下。 最后记录自由元的个数(设为x)方案数就是2^x. 若某一行系数全是0结果却是1，那这是不可能的。 怎么求自由元？若A[i][i] = 0则第i个灯是自由元。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define MAX_N 30using namespace std;int fr[MAX_N], be[MAX_N];int A[MAX_N][MAX_N], B[MAX_N];int free_x[MAX_N];int N;int check_ () &#123; for(int i = 1;i &lt;= N; ++i) &#123; int sum = 0; for(int j = 1;j &lt;= N; ++j) if(A[i][j] == 0) sum++; if(sum == N &amp;&amp; B[i] == 1) return 1; &#125; return 0;&#125;void print_false () &#123; printf("Oh,it's impossible~!!\n");&#125;void cal () &#123; int res = 1; for(int i = 1;i &lt;= N; ++i) if(free_x[i]) res *= 2; printf("%d\n", res);&#125;void gauss () &#123; memset(free_x, 0, sizeof(free_x)); for(int i = 1;i &lt;= N; ++i) &#123; int k = i; for (int j = i+1; j &lt;= N; ++j) if (A[j][i] &gt; A[k][i]) k = j; if(A[k][i] == 0) free_x[i] = 1; if (k != i)&#123; for (int j = 1; j &lt;= N; ++j) std::swap(A[i][j], A[k][j]); std::swap(B[i], B[k]); &#125; for(int j = i + 1;j &lt;= N; ++j) &#123; if(A[j][i] == 0) continue; for(int k = 1;k &lt;= N; ++k) A[j][k] ^= A[i][k]; B[j] ^= B[i]; &#125; &#125; if(check_() == 1) print_false(); else cal();&#125;void solve () &#123; //Read() scanf("%d", &amp;N); for(int i = 1;i &lt;= N; ++i) scanf("%d", &amp;fr[i]); for(int i = 1;i &lt;= N; ++i) &#123; scanf("%d", &amp;be[i]); B[i] = fr[i] ^ be[i]; &#125; int a, b; for(int i = 1;i &lt;= N; ++i) A[i][i] = 1; while(scanf("%d%d", &amp;a, &amp;b) == 2 &amp;&amp; a != 0 &amp;&amp; b != 0) A[b][a] = 1; gauss();&#125;void init () &#123; memset(fr, 0, sizeof(fr)); memset(be, 0, sizeof(be)); memset(A, 0, sizeof(A)); memset(B, 0, sizeof(B));&#125;int main () &#123; int ntot; scanf("%d", &amp;ntot); while(ntot--) &#123; init(); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元模板题luogu3389题解]]></title>
    <url>%2F2017%2F12%2F29%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%A8%A1%E6%9D%BF%E9%A2%98luogu3389%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目背景Gauss消元 题目描述给定一个线性方程组，对其求解 输入输出格式输入格式：第一行，一个正整数 nnn 第二至 n+1行，每行 n+1 个整数，为a1, a2 … an和 b，代表一组方程。 输出格式：共n行，每行一个数，第 i行为x_i （保留2位小数） 如果不存在唯一解，在第一行输出”No Solution”. 输入输出样例输入样例#1： 31 3 4 51 4 7 39 3 2 2输出样例#1： -0.975.18-2.39 说明 1≤n≤100,∣ai∣≤104,∣b∣≤104 解题报告 这就是个高斯消元的模板题，一开始还认为很难，又找wikipedia,又找百度百科. 虽然最后没有什么用，但是还是把链接贴上: wiki : https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95 baidu : https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/619561?fr=aladdin 一开始看完wiki上面的高斯消元大概知道只有唯一解的方法怎么写了，但是唯一一个问题就是 怎么判断无解或者有多个解。 所以就因为这个问题看wiki和百科看了一个多小时，最后还是不懂(不禁吐槽wiki后面写的晦涩难懂) 后来问了dra, 他就说这题很简单，你直接用平常你解方程的方法去判断 我一想，好像就是这样就可以了。 然后怎么会无解呢:已知最后会化简成a * x = b的形式，如果此时系数a为0就不行。 怎么会又无穷多个解呢: 就是存在自由元啊，如果matr[i][i]==0说明x[i]是个自由元. 所以这题就做出来了. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define MAX_N 1005using namespace std;// problemint N;double matr[MAX_N][MAX_N];// recorddouble free_line[MAX_N];void cal () &#123; matr[N][N + 1] /= matr[N][N]; for(int i = N - 1;i &gt; 0; --i) &#123; // 处理每一行 double sum = 0; for(int j = i + 1; j &lt;= N; ++j) &#123; sum += matr[i][j] * matr[j][N + 1]; //printf("%lf %lf %lf\n", matr[i][j], matr[j][N + 1], sum); &#125; matr[i][N + 1] = (matr[i][N + 1] - sum) / matr[i][i]; &#125; for(int i = 1;i &lt;= N; ++i) printf("%.2lf\n", matr[i][N + 1]);&#125;void solve () &#123; for(int tot = 1;tot &lt; N; ++tot) &#123; double stan = matr[tot][tot]; for(int i = tot + 1;i &lt;= N; ++i) &#123; //把tot列的元都消掉 if(matr[i][tot] == 0) continue; double now = matr[i][tot] / stan; for(int j = 1;j &lt;= N + 1; ++j) &#123; matr[i][j] -= matr[tot][j] * now; &#125; &#125; &#125; if(matr[N][N] == 0) &#123;printf("No Solution\n");exit(0);&#125; else cal();&#125;int main () &#123; scanf("%d", &amp;N); for(int i = 1;i &lt;= N; ++i) for(int j = 1;j &lt;= N + 1; ++j) &#123; scanf("%lf", &amp;matr[i][j]); if(matr[i][j] == 0) free_line[j]++; &#125; // special situation for(int i = 1;i &lt;= N; ++i) if(free_line[i] == N) &#123; printf("No Solution\n"); return 0; &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>洛谷</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first article]]></title>
    <url>%2F2017%2F12%2F29%2FMy-first-article%2F</url>
    <content type="text"><![CDATA[一年中最后几天才开始动手搭建这个blog真是有意思啊再见 2017!你好 2018!]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
